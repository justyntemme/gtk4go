# Git Repository Content Extraction
# Generated on Tue Mar 25 07:00:18 PM CDT 2025
# Repository: git@github.com:justyntemme/gtk4go.git

Breaking changes are just fine, and encouraged when it's a refactor for cleaner more performant code.
############################################################
# File: background.go
############################################################

// Package gtk4go provides async worker functionality for GTK4.
// File: gtk4go/background.go
package gtk4go

import (
	"context"
	"fmt"
	"runtime"
	"sync"
	"sync/atomic"
	"time"
)

// BackgroundWorker handles running tasks in the background
// while providing updates to the UI thread
type BackgroundWorker struct {
	workQueue     chan *WorkItem
	stopChan      chan struct{}
	wg            sync.WaitGroup
	isRunning     atomic.Bool
	activeWorkers atomic.Int32
	workerCount   atomic.Int32
	nextTaskID    atomic.Uint64
	mu            sync.RWMutex // Used only for fields not amenable to atomic ops
}

// WorkStatus represents the status of a background task
type WorkStatus int32

const (
	// StatusPending indicates the task is pending
	StatusPending WorkStatus = iota
	// StatusRunning indicates the task is running
	StatusRunning
	// StatusCompleted indicates the task completed successfully
	StatusCompleted
	// StatusFailed indicates the task failed with an error
	StatusFailed
	// StatusCancelled indicates the task was cancelled
	StatusCancelled
)

// WorkItem represents a unit of work to be processed
type WorkItem struct {
	ID          string
	Task        func(ctx context.Context, progress func(percent int, message string)) (interface{}, error)
	OnProgress  func(percent int, message string)
	OnComplete  func(result interface{}, err error)
	status      atomic.Int32 // Using atomic int32 for WorkStatus
	result      atomic.Value // For storing the result
	err         atomic.Value // For storing the error
	ctx         context.Context
	cancelFunc  context.CancelFunc
	
	// Progress tracking
	progressMu    sync.Mutex      // Traditional mutex for complex progress operations
	lastUpdate    atomic.Value    // Using atomic.Value for time.Time
	updateDelay   time.Duration   // Update frequency limitation
	progressCalls atomic.Int64    // Count of progress calls for metrics
}

// NewBackgroundWorker creates a new background worker
func NewBackgroundWorker(numWorkers int) *BackgroundWorker {
	if numWorkers <= 0 {
		numWorkers = runtime.NumCPU()
	}

	worker := &BackgroundWorker{
		workQueue: make(chan *WorkItem, 100),
		stopChan:  make(chan struct{}),
	}
	
	// Set initial state
	worker.isRunning.Store(true)
	worker.workerCount.Store(int32(numWorkers))

	// Start worker goroutines
	worker.wg.Add(numWorkers)
	for i := 0; i < numWorkers; i++ {
		workerID := i
		go worker.processWork(workerID)
	}

	return worker
}

// processWork runs in a goroutine to process work items
func (w *BackgroundWorker) processWork(workerID int) {
	defer w.wg.Done()
	
	// Track active worker count
	w.activeWorkers.Add(1)
	defer w.activeWorkers.Add(-1)

	for {
		select {
		case <-w.stopChan:
			return
		case item := <-w.workQueue:
			if item == nil {
				continue
			}

			// Mark as running using atomic operation
			item.status.Store(int32(StatusRunning))

			// Create a progress function that runs on UI thread
			progressFunc := func(percent int, message string) {
				// Use atomic operations for thread-safe time checks
				lastUpdateObj := item.lastUpdate.Load()
				var lastUpdate time.Time
				if lastUpdateObj != nil {
					lastUpdate = lastUpdateObj.(time.Time)
				}
				
				now := time.Now()
				
				// Rate limiting check
				item.progressMu.Lock()
				updateDelay := item.updateDelay
				shouldUpdate := now.Sub(lastUpdate) >= updateDelay
				if shouldUpdate {
					item.lastUpdate.Store(now)
				}
				item.progressMu.Unlock()
				
				if !shouldUpdate {
					return
				}
				
				// Increment progress call counter
				item.progressCalls.Add(1)

				if item.OnProgress != nil {
					RunOnUIThread(func() {
						item.OnProgress(percent, message)
					})
				}
			}

			// Execute the task
			result, err := item.Task(item.ctx, progressFunc)

			// Store result/error using atomic operations
			if result != nil {
				item.result.Store(result)
			}
			
			if err != nil {
				item.err.Store(err)
			}

			// Check if cancelled using atomic operations
			var finalStatus WorkStatus
			if item.ctx.Err() == context.Canceled {
				finalStatus = StatusCancelled
			} else if err != nil {
				finalStatus = StatusFailed
			} else {
				finalStatus = StatusCompleted
			}
			
			item.status.Store(int32(finalStatus))

			// Execute completion callback on UI thread
			if item.OnComplete != nil {
				RunOnUIThread(func() {
					// Safely retrieve result/error from atomic storage
					var resultVal interface{}
					if r := item.result.Load(); r != nil {
						resultVal = r
					}
					
					var errVal error
					if e := item.err.Load(); e != nil {
						errVal = e.(error)
					}
					
					item.OnComplete(resultVal, errVal)
				})
			}
		}
	}
}

// QueueTask queues a task for background execution
func (w *BackgroundWorker) QueueTask(
	id string,
	task func(ctx context.Context, progress func(percent int, message string)) (interface{}, error),
	onComplete func(result interface{}, err error),
	onProgress func(percent int, message string),
) context.CancelFunc {
	// Check if we're running using atomic operations
	if !w.isRunning.Load() {
		if onComplete != nil {
			RunOnUIThread(func() {
				onComplete(nil, fmt.Errorf("worker is not running"))
			})
		}
		return func() {}
	}
	
	// Generate ID if none provided
	if id == "" {
		id = fmt.Sprintf("task-%d", w.nextTaskID.Add(1))
	}

	// Create cancellable context
	ctx, cancelFunc := context.WithCancel(context.Background())

	item := &WorkItem{
		ID:          id,
		Task:        task,
		OnProgress:  onProgress,
		OnComplete:  onComplete,
		ctx:         ctx,
		cancelFunc:  cancelFunc,
		updateDelay: 100 * time.Millisecond, // Update UI at most every 100ms
	}
	
	// Initialize atomic values
	item.status.Store(int32(StatusPending))
	item.lastUpdate.Store(time.Now())

	// Try to queue the work with a timeout to prevent deadlocks
	select {
	case w.workQueue <- item:
		// Successfully queued
	case <-time.After(100 * time.Millisecond):
		// Queue is full or blocked
		if onComplete != nil {
			RunOnUIThread(func() {
				onComplete(nil, fmt.Errorf("work queue is full"))
			})
		}
		cancelFunc()
	}

	return cancelFunc
}

// SetProgressUpdateInterval sets the minimum time between progress updates
func (w *BackgroundWorker) SetProgressUpdateInterval(duration time.Duration) {
	// This only affects new tasks
	w.mu.Lock()
	defer w.mu.Unlock()
	// Would be stored in a field if we needed it
}

// GetActiveWorkerCount returns the number of currently active workers
func (w *BackgroundWorker) GetActiveWorkerCount() int {
	return int(w.activeWorkers.Load())
}

// IsRunning returns whether the worker is currently running
func (w *BackgroundWorker) IsRunning() bool {
	return w.isRunning.Load()
}

// Stop stops the worker and waits for all tasks to complete
func (w *BackgroundWorker) Stop() {
	// Use atomic operation to check and update running state
	if !w.isRunning.CompareAndSwap(true, false) {
		// Already stopped
		return
	}
	
	close(w.stopChan)

	// Wait for all workers to finish
	w.wg.Wait()
}

// Shutdown stops the worker and cancels any pending or running tasks
func (w *BackgroundWorker) Shutdown(timeout time.Duration) bool {
	// Stop accepting new tasks
	if !w.isRunning.CompareAndSwap(true, false) {
		// Already stopped
		return true
	}

	// Close the stop channel to signal workers to exit
	close(w.stopChan)

	// Use a channel to signal completion
	done := make(chan struct{})
	go func() {
		w.wg.Wait()
		close(done)
	}()

	// Wait for workers to finish with timeout
	select {
	case <-done:
		return true
	case <-time.After(timeout):
		return false
	}
}

// DefaultWorker is the default background worker
var DefaultWorker = NewBackgroundWorker(runtime.NumCPU())

// QueueBackgroundTask is a convenience function that queues a task on the default worker
func QueueBackgroundTask(
	id string,
	task func(ctx context.Context, progress func(percent int, message string)) (interface{}, error),
	onComplete func(result interface{}, err error),
	onProgress func(percent int, message string),
) context.CancelFunc {
	return DefaultWorker.QueueTask(id, task, onComplete, onProgress)
}

// RunInBackground runs a simple task without progress updates
func RunInBackground(
	task func() (interface{}, error),
	onComplete func(result interface{}, err error),
) context.CancelFunc {
	wrappedTask := func(ctx context.Context, _ func(int, string)) (interface{}, error) {
		// Check for cancellation
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
			// Continue with task
		}

		return task()
	}

	return QueueBackgroundTask("", wrappedTask, onComplete, nil)
}

// ShutdownDefaultWorker shuts down the default worker with a timeout
func ShutdownDefaultWorker(timeout time.Duration) bool {
	return DefaultWorker.Shutdown(timeout)
}

// init ensures we clean up the default worker when the program exits
func init() {
	// Register a cleanup function to be called at exit if possible
	runtime.SetFinalizer(DefaultWorker, func(w *BackgroundWorker) {
		w.Stop()
	})
}

############################################################
# File: gtk4/action.go
############################################################

// Package gtk4 provides modern action-based menu functionality for GTK4
// File: gtk4go/gtk4/action.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Export our action activation callback
// extern void actionActivateCallback(GSimpleAction *action, GVariant *parameter, gpointer user_data);
//
// // Create simple action without connecting a callback
// static GSimpleAction* createSimpleAction(const char* name) {
//     return g_simple_action_new(name, NULL);
// }
//
// // Add action to action map
// static void addActionToMap(GActionMap *map, GAction *action) {
//     g_action_map_add_action(map, action);
// }
//
// // Set application menu bar
// static void setApplicationMenuBar(GtkApplication* app, GMenuModel* menu_model) {
//     gtk_application_set_menubar(app, menu_model);
// }
//
// // Helper function to explicitly connect the activate signal
// static gulong connectActionActivate(GSimpleAction *action, gpointer callback_data) {
//     return g_signal_connect(action, "activate", G_CALLBACK(actionActivateCallback), callback_data);
// }
import "C"

import (
	"unsafe"
)

// ActionCallback represents a callback for action activation
type ActionCallback func()

// ActionGroup represents a GTK action group
type ActionGroup interface {
	AddAction(action *Action)
	RemoveAction(name string)
}

// Action represents a GTK action
type Action struct {
	action *C.GSimpleAction
	name   string
}

// NewAction creates a new GTK action
func NewAction(name string, callback ActionCallback) *Action {
	cName := C.CString(name)
	defer C.free(unsafe.Pointer(cName))

	// Create a simple action with no parameter
	action := C.createSimpleAction(cName)

	// Create the Action instance
	a := &Action{
		action: action,
		name:   name,
	}

	// Connect the callback using the DIRECT C pointer of the action
	// This is critical - we need to register the callback with the exact pointer
	// that will be used in the actionActivateCallback function
	actionPtr := uintptr(unsafe.Pointer(action))

	// Debug the action pointer for reference
	DebugLog(DebugLevelInfo, DebugComponentAction, "Registering action %s with pointer %p", name, unsafe.Pointer(action))

	// Convert the ActionCallback to a standard func() before storing
	// This is crucial because the callback system doesn't recognize ActionCallback
	// but it does recognize plain func()
	standardCallback := func() {
		callback()
	}

	// Store the callback directly with the action pointer as the key
	StoreDirectCallback(actionPtr, SignalActionActivate, standardCallback)

	// Also connect directly to the action's activate signal
	// This ensures the signal is triggered when a menu item is clicked
	C.connectActionActivate(action, C.gpointer(unsafe.Pointer(action)))

	return a
}

// StoreDirectCallback is a helper function to directly store a callback for a pointer
// This bypasses the normal Connect mechanism to ensure direct pointer matching
func StoreDirectCallback(ptr uintptr, signal SignalType, callback interface{}) {
	// Access the global callback manager's maps directly
	globalCallbackManager.objectCallbacks.Store(ptr, map[SignalType]interface{}{
		signal: callback,
	})

	DebugLog(DebugLevelInfo, DebugComponentCallback,
		"Directly stored callback for pointer %v and signal %s", ptr, signal)
}

// GetNative returns the underlying GAction pointer
func (a *Action) GetNative() *C.GAction {
	return (*C.GAction)(unsafe.Pointer(a.action))
}

// GetName returns the action name
func (a *Action) GetName() string {
	return a.name
}

// Free frees resources associated with the action
func (a *Action) Free() {
	if a.action != nil {
		// Disconnect all callbacks using the unified callback system
		// Use the direct action pointer for disconnection
		actionPtr := uintptr(unsafe.Pointer(a.action))

		// Remove from objectCallbacks map
		globalCallbackManager.objectCallbacks.Delete(actionPtr)

		C.g_object_unref(C.gpointer(unsafe.Pointer(a.action)))
		a.action = nil
	}
}

// ApplicationActionGroup implements the ActionGroup interface for Application
type ApplicationActionGroup struct {
	app *Application
}

// AddAction adds an action to the application
func (a *ApplicationActionGroup) AddAction(action *Action) {
	C.addActionToMap((*C.GActionMap)(unsafe.Pointer(a.app.app)), action.GetNative())
}

// RemoveAction removes an action from the application
func (a *ApplicationActionGroup) RemoveAction(name string) {
	cName := C.CString(name)
	defer C.free(unsafe.Pointer(cName))
	C.g_action_map_remove_action((*C.GActionMap)(unsafe.Pointer(a.app.app)), cName)
}

// GetActionGroup returns the application's action group
func (a *Application) GetActionGroup() ActionGroup {
	return &ApplicationActionGroup{app: a}
}

// SetMenuBar sets the application menu bar
func (a *Application) SetMenuBar(menu *Menu) {
	// In the menu implementation for GTK4, we should set the menu model
	// directly on the application. For a valid implementation, we'd need to
	// ensure the application is registered first, but for this PoC we'll
	// use the direct approach.
	C.setApplicationMenuBar(a.app, menu.GetMenuModel())
}

// Popover represents a GTK popover
type Popover struct {
	BaseWidget
}

// NewPopover creates a new GTK popover
func NewPopover() *Popover {
	popover := &Popover{
		BaseWidget: BaseWidget{
			widget: C.gtk_popover_new(),
		},
	}

	SetupFinalization(popover, popover.Destroy)
	return popover
}

// SetChild sets the child widget for the popover
func (p *Popover) SetChild(child Widget) {
	C.gtk_popover_set_child(
		(*C.GtkPopover)(unsafe.Pointer(p.widget)),
		child.GetWidget(),
	)
}

// SetPointingTo sets the rectangle the popover points to
func (p *Popover) SetPointingTo(rect *C.GdkRectangle) {
	C.gtk_popover_set_pointing_to(
		(*C.GtkPopover)(unsafe.Pointer(p.widget)),
		rect,
	)
}

// SetPosition sets the position of the popover relative to the parent widget
func (p *Popover) SetPosition(position C.GtkPositionType) {
	C.gtk_popover_set_position(
		(*C.GtkPopover)(unsafe.Pointer(p.widget)),
		position,
	)
}

// SetAutohide sets whether to hide the popover when clicked outside
func (p *Popover) SetAutohide(autohide bool) {
	var cautohide C.gboolean
	if autohide {
		cautohide = C.TRUE
	} else {
		cautohide = C.FALSE
	}
	C.gtk_popover_set_autohide(
		(*C.GtkPopover)(unsafe.Pointer(p.widget)),
		cautohide,
	)
}

// SetDefaultWidget sets the default widget for the popover
func (p *Popover) SetDefaultWidget(widget Widget) {
	C.gtk_popover_set_default_widget(
		(*C.GtkPopover)(unsafe.Pointer(p.widget)),
		widget.GetWidget(),
	)
}

// Popup shows the popover
func (p *Popover) Popup() {
	C.gtk_popover_popup((*C.GtkPopover)(unsafe.Pointer(p.widget)))
}

// Popdown hides the popover
func (p *Popover) Popdown() {
	C.gtk_popover_popdown((*C.GtkPopover)(unsafe.Pointer(p.widget)))
}

//export actionActivateCallback
func actionActivateCallback(action *C.GSimpleAction, parameter *C.GVariant, userData C.gpointer) {
	DebugLog(DebugLevelVerbose, DebugComponentAction, "Action activated: %p", unsafe.Pointer(action))

	// Convert action pointer to uintptr for lookup
	actionPtr := uintptr(unsafe.Pointer(action))

	// Get the callback from the objectCallbacks map directly
	var callback interface{}

	// Try to find the callback for this action pointer
	callbackMapObj, ok := globalCallbackManager.objectCallbacks.Load(actionPtr)
	if ok {
		callbackMap := callbackMapObj.(map[SignalType]interface{})
		callback = callbackMap[SignalActionActivate]
	}

	if callback != nil {
		// Execute the callback
		DebugLog(DebugLevelInfo, DebugComponentAction, "Found callback for action: %p", unsafe.Pointer(action))
		SafeCallback(callback)
	} else {
		DebugLog(DebugLevelWarning, DebugComponentAction,
			"No callback found for action: %p (action may not be registered correctly)", unsafe.Pointer(action))

		// Dump the current action registrations for debugging
		dumpActionCallbacks()
	}
}

// Debug helper to dump all registered action callbacks
func dumpActionCallbacks() {
	callbackCount := 0
	globalCallbackManager.objectCallbacks.Range(func(key, value interface{}) bool {
		ptr := key.(uintptr)
		callbackMap := value.(map[SignalType]interface{})

		// See if it has an action activate signal
		if cb, ok := callbackMap[SignalActionActivate]; ok {
			callbackCount++
			DebugLog(DebugLevelInfo, DebugComponentAction,
				"Registered action callback: ptr=%v, callback=%T", ptr, cb)
		}
		return true
	})

	DebugLog(DebugLevelInfo, DebugComponentAction,
		"Found %d registered action callbacks", callbackCount)
}



############################################################
# File: gtk4/adjustment.go
############################################################

// Package gtk4 provides adjustment functionality for GTK4
// File: gtk4go/gtk4/adjustment.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Signal callback function for adjustment value changes
// extern void adjustmentValueChangedCallback(GtkAdjustment *adjustment, gpointer user_data);
//
// // Connect adjustment value-changed signal with callback
// static gulong connectAdjustmentValueChanged(GtkAdjustment *adjustment, gpointer user_data) {
//     return g_signal_connect(G_OBJECT(adjustment), "value-changed", G_CALLBACK(adjustmentValueChangedCallback), user_data);
// }
import "C"

import (
	"runtime"
	"sync"
	"unsafe"
)

// AdjustmentValueChangedCallback represents a callback for adjustment value changed events
type AdjustmentValueChangedCallback func()

var (
	adjustmentCallbacks     = make(map[uintptr]AdjustmentValueChangedCallback)
	adjustmentCallbackMutex sync.RWMutex
)

//export adjustmentValueChangedCallback
func adjustmentValueChangedCallback(adjustment *C.GtkAdjustment, userData C.gpointer) {
	adjustmentCallbackMutex.RLock()
	defer adjustmentCallbackMutex.RUnlock()

	// Convert adjustment pointer to uintptr for lookup
	adjustmentPtr := uintptr(unsafe.Pointer(adjustment))

	// Find and call the callback
	if callback, ok := adjustmentCallbacks[adjustmentPtr]; ok {
		callback()
	}
}

// AdjustmentOption is a function that configures an adjustment
type AdjustmentOption func(*Adjustment)

// Adjustment represents a GTK adjustment
type Adjustment struct {
	adjustment *C.GtkAdjustment
}

// NewAdjustment creates a new GTK adjustment
func NewAdjustment(value, lower, upper, stepIncrement, pageIncrement, pageSize float64, options ...AdjustmentOption) *Adjustment {
	adjustment := &Adjustment{
		adjustment: C.gtk_adjustment_new(
			C.gdouble(value),
			C.gdouble(lower),
			C.gdouble(upper),
			C.gdouble(stepIncrement),
			C.gdouble(pageIncrement),
			C.gdouble(pageSize),
		),
	}

	// Apply options
	for _, option := range options {
		option(adjustment)
	}

	runtime.SetFinalizer(adjustment, (*Adjustment).Free)
	return adjustment
}

// WithValue sets the initial value of the adjustment
func WithValue(value float64) AdjustmentOption {
	return func(a *Adjustment) {
		a.SetValue(value)
	}
}

// WithRange sets the range of the adjustment
func WithRange(lower, upper float64) AdjustmentOption {
	return func(a *Adjustment) {
		a.SetLower(lower)
		a.SetUpper(upper)
	}
}

// WithStepIncrement sets the step increment of the adjustment
func WithStepIncrement(step float64) AdjustmentOption {
	return func(a *Adjustment) {
		a.SetStepIncrement(step)
	}
}

// WithPageIncrement sets the page increment of the adjustment
func WithPageIncrement(page float64) AdjustmentOption {
	return func(a *Adjustment) {
		a.SetPageIncrement(page)
	}
}

// WithPageSize sets the page size of the adjustment
func WithPageSize(size float64) AdjustmentOption {
	return func(a *Adjustment) {
		a.SetPageSize(size)
	}
}

// GetValue gets the value of the adjustment
func (a *Adjustment) GetValue() float64 {
	return float64(C.gtk_adjustment_get_value(a.adjustment))
}

// SetValue sets the value of the adjustment
func (a *Adjustment) SetValue(value float64) {
	C.gtk_adjustment_set_value(a.adjustment, C.gdouble(value))
}

// GetLower gets the lower bound of the adjustment
func (a *Adjustment) GetLower() float64 {
	return float64(C.gtk_adjustment_get_lower(a.adjustment))
}

// SetLower sets the lower bound of the adjustment
func (a *Adjustment) SetLower(lower float64) {
	C.gtk_adjustment_set_lower(a.adjustment, C.gdouble(lower))
}

// GetUpper gets the upper bound of the adjustment
func (a *Adjustment) GetUpper() float64 {
	return float64(C.gtk_adjustment_get_upper(a.adjustment))
}

// SetUpper sets the upper bound of the adjustment
func (a *Adjustment) SetUpper(upper float64) {
	C.gtk_adjustment_set_upper(a.adjustment, C.gdouble(upper))
}

// GetStepIncrement gets the step increment of the adjustment
func (a *Adjustment) GetStepIncrement() float64 {
	return float64(C.gtk_adjustment_get_step_increment(a.adjustment))
}

// SetStepIncrement sets the step increment of the adjustment
func (a *Adjustment) SetStepIncrement(step float64) {
	C.gtk_adjustment_set_step_increment(a.adjustment, C.gdouble(step))
}

// GetPageIncrement gets the page increment of the adjustment
func (a *Adjustment) GetPageIncrement() float64 {
	return float64(C.gtk_adjustment_get_page_increment(a.adjustment))
}

// SetPageIncrement sets the page increment of the adjustment
func (a *Adjustment) SetPageIncrement(page float64) {
	C.gtk_adjustment_set_page_increment(a.adjustment, C.gdouble(page))
}

// GetPageSize gets the page size of the adjustment
func (a *Adjustment) GetPageSize() float64 {
	return float64(C.gtk_adjustment_get_page_size(a.adjustment))
}

// SetPageSize sets the page size of the adjustment
func (a *Adjustment) SetPageSize(size float64) {
	C.gtk_adjustment_set_page_size(a.adjustment, C.gdouble(size))
}

// ConnectValueChanged connects a callback to the value-changed signal
func (a *Adjustment) ConnectValueChanged(callback AdjustmentValueChangedCallback) {
	adjustmentCallbackMutex.Lock()
	defer adjustmentCallbackMutex.Unlock()

	// Store callback in map
	adjustmentPtr := uintptr(unsafe.Pointer(a.adjustment))
	adjustmentCallbacks[adjustmentPtr] = callback

	// Connect signal
	C.connectAdjustmentValueChanged(a.adjustment, C.gpointer(unsafe.Pointer(a.adjustment)))
}

// DisconnectValueChanged disconnects the value-changed signal handler
func (a *Adjustment) DisconnectValueChanged() {
	adjustmentCallbackMutex.Lock()
	defer adjustmentCallbackMutex.Unlock()

	// Remove callback from map
	adjustmentPtr := uintptr(unsafe.Pointer(a.adjustment))
	delete(adjustmentCallbacks, adjustmentPtr)
}

// Free frees the adjustment
func (a *Adjustment) Free() {
	if a.adjustment != nil {
		adjustmentCallbackMutex.Lock()
		defer adjustmentCallbackMutex.Unlock()

		// Remove callback from map if exists
		adjustmentPtr := uintptr(unsafe.Pointer(a.adjustment))
		delete(adjustmentCallbacks, adjustmentPtr)

		C.g_object_unref(C.gpointer(unsafe.Pointer(a.adjustment)))
		a.adjustment = nil
	}
}


############################################################
# File: gtk4/application.go
############################################################

// Package gtk4 provides application functionality for GTK4
// File: gtk4go/gtk4/application.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Callback struct to pass Go function through C
// typedef struct {
//     void* window;
//     void* app;
// } ActivateData;
//
// // Activate callback
// static void activateCallback(GtkApplication* app, gpointer user_data) {
//     ActivateData* data = (ActivateData*)user_data;
//     GtkWidget* window = (GtkWidget*)data->window;
//
//     // Set application
//     gtk_window_set_application(GTK_WINDOW(window), app);
//
//     // Show the window
//     gtk_widget_set_visible(window, TRUE);
// }
//
// // Connect activate signal
// static void connect_activate(GtkApplication* app, GtkWidget* window) {
//     ActivateData* data = malloc(sizeof(ActivateData));
//     data->window = window;
//     data->app = app;
//
//     g_signal_connect(app, "activate", G_CALLBACK(activateCallback), data);
// }
import "C"

import (
	"runtime"
	"unsafe"
)

// ApplicationOption is a function that configures an application
type ApplicationOption func(*Application)

// Application represents a GTK application
type Application struct {
	app *C.GtkApplication
}

// NewApplication creates a new GTK application with the given ID
func NewApplication(id string, options ...ApplicationOption) *Application {
	cID := C.CString(id)
	defer C.free(unsafe.Pointer(cID))

	app := &Application{
		app: C.gtk_application_new(cID, C.G_APPLICATION_DEFAULT_FLAGS),
	}
	
	// Apply options
	for _, option := range options {
		option(app)
	}
	
	runtime.SetFinalizer(app, (*Application).Destroy)
	return app
}

// WithAction adds an action to the application at creation time
func WithAction(action *Action) ApplicationOption {
	return func(a *Application) {
		a.GetActionGroup().AddAction(action)
	}
}

// WithMenuBar sets the application menu bar at creation time
func WithMenuBar(menu *Menu) ApplicationOption {
	return func(a *Application) {
		a.SetMenuBar(menu)
	}
}

// AddWindow adds a window to the application and connects the activate signal
func (a *Application) AddWindow(window any) {
	if w, ok := window.(interface{ GetWidget() *C.GtkWidget }); ok {
		// Connect the activate signal to handle window display
		C.connect_activate(a.app, w.GetWidget())
	}
}

// Run runs the application
func (a *Application) Run() int {
	status := C.g_application_run((*C.GApplication)(unsafe.Pointer(a.app)), 0, nil)
	return int(status)
}

// Destroy destroys the application
func (a *Application) Destroy() {
	C.g_object_unref(C.gpointer(unsafe.Pointer(a.app)))
}

############################################################
# File: gtk4/base.go
############################################################

// Package gtk4 provides base widget functionality for GTK4
// File: gtk4go/gtk4/base.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"runtime"
	"sync"
	"unsafe"
)

// Widget defines the common interface for GTK widgets
type Widget interface {
	// GetWidget returns the underlying GtkWidget pointer
	GetWidget() *C.GtkWidget

	// Native returns the underlying pointer as uintptr
	Native() uintptr

	// Destroy releases the widget resources
	Destroy()

	// AddCssClass adds a CSS class to the widget
	AddCssClass(className string)

	// RemoveCssClass removes a CSS class from the widget
	RemoveCssClass(className string)

	// HasCssClass checks if the widget has a CSS class
	HasCssClass(className string) bool
}

// BaseWidget provides common functionality for GTK widgets
type BaseWidget struct {
	widget *C.GtkWidget
}

// GetWidget returns the underlying GtkWidget pointer
func (w *BaseWidget) GetWidget() *C.GtkWidget {
	return w.widget
}

// Native returns the underlying GtkWidget pointer as uintptr
func (w *BaseWidget) Native() uintptr {
	return uintptr(unsafe.Pointer(w.widget))
}

// Destroy destroys the widget
func (w *BaseWidget) Destroy() {
	if w.widget != nil {
		C.gtk_widget_unparent(w.widget)
		w.widget = nil
	}
}

// AddCssClass adds a CSS class to the widget
func (w *BaseWidget) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(w.widget, cClassName)
}

// RemoveCssClass removes a CSS class from the widget
func (w *BaseWidget) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(w.widget, cClassName)
}

// HasCssClass checks if the widget has a CSS class
func (w *BaseWidget) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C.gtk_widget_has_css_class(w.widget, cClassName) == 1
}

// SetChild sets the child widget
// Note: Not all GTK widgets support this operation directly.
// For containers like Box, Grid, etc., use their specific methods instead.
func (w *BaseWidget) SetChild(child Widget) {
	if child != nil {
		// Use the appropriate child-setting function based on widget type
		// This requires type detection at runtime (not ideal but works for demo)
		
		// For GtkWindow we can use gtk_window_set_child
		C.gtk_window_set_child((*C.GtkWindow)(unsafe.Pointer(w.widget)), child.GetWidget())
	} else {
		// Clear the child
		C.gtk_window_set_child((*C.GtkWindow)(unsafe.Pointer(w.widget)), nil)
	}
}

// WithCString executes a function with a C string that is automatically freed
func WithCString(s string, fn func(*C.char)) {
	cs := C.CString(s)
	defer C.free(unsafe.Pointer(cs))
	fn(cs)
}

// CastToGObject casts a widget pointer to a GObject pointer
func CastToGObject(widget *C.GtkWidget) *C.GObject {
	return (*C.GObject)(unsafe.Pointer(widget))
}

// SetupFinalization sets up proper finalization for a widget
func SetupFinalization(widget Widget, destroyFunc func()) {
	runtime.SetFinalizer(widget, func(w Widget) {
		destroyFunc()
	})
}

// SignalHandlerRegistry is a global registry for signal handlers
var SignalHandlerRegistry = NewSignalHandler()

// SignalHandler manages signals and callbacks for GTK widgets
type SignalHandler struct {
	callbacks     map[uintptr]map[string]interface{}
	callbackMutex sync.RWMutex
}

// NewSignalHandler creates a new signal handler
func NewSignalHandler() *SignalHandler {
	return &SignalHandler{
		callbacks: make(map[uintptr]map[string]interface{}),
	}
}

// Connect connects a callback to a signal
func (s *SignalHandler) Connect(widget uintptr, signal string, callback interface{}) {
	s.callbackMutex.Lock()
	defer s.callbackMutex.Unlock()

	if _, ok := s.callbacks[widget]; !ok {
		s.callbacks[widget] = make(map[string]interface{})
	}

	s.callbacks[widget][signal] = callback
}

// Disconnect disconnects a specific callback for a widget and signal
func (s *SignalHandler) Disconnect(widget uintptr, signal string) {
	s.callbackMutex.Lock()
	defer s.callbackMutex.Unlock()

	if callbackMap, ok := s.callbacks[widget]; ok {
		delete(callbackMap, signal)
		// Remove the widget from the map if no more signals are connected
		if len(callbackMap) == 0 {
			delete(s.callbacks, widget)
		}
	}
}

// DisconnectAll disconnects all callbacks for a widget
func (s *SignalHandler) DisconnectAll(widget uintptr) {
	s.callbackMutex.Lock()
	defer s.callbackMutex.Unlock()

	delete(s.callbacks, widget)
}

// Get retrieves a callback for a widget and signal
func (s *SignalHandler) Get(widget uintptr, signal string) interface{} {
	s.callbackMutex.RLock()
	defer s.callbackMutex.RUnlock()

	if callbackMap, ok := s.callbacks[widget]; ok {
		if callback, ok := callbackMap[signal]; ok {
			return callback
		}
	}

	return nil
}

// Has checks if a callback exists for a widget and signal
func (s *SignalHandler) Has(widget uintptr, signal string) bool {
	s.callbackMutex.RLock()
	defer s.callbackMutex.RUnlock()

	if callbackMap, ok := s.callbacks[widget]; ok {
		_, ok := callbackMap[signal]
		return ok
	}

	return false
}

// GTKError represents an error in GTK operations
type GTKError struct {
	Op  string
	Err error
}

// Error implements the error interface
func (e *GTKError) Error() string {
	if e.Err != nil {
		return "gtk4go: " + e.Op + ": " + e.Err.Error()
	}
	return "gtk4go: " + e.Op
}

// SafeCallback safely executes a callback on the UI thread
func SafeCallback(callback interface{}, args ...interface{}) {
	// Import the main package for UI thread functions
	// This avoids import cycles
	if callback == nil {
		return
	}

	// Execute the callback based on its type
	switch cb := callback.(type) {
	case func():
		// Simple callback with no arguments
		cb()
	case func(interface{}):
		// Callback with a single argument
		if len(args) > 0 {
			cb(args[0])
		} else {
			cb(nil)
		}
	case func(interface{}, interface{}):
		// Callback with two arguments
		if len(args) > 1 {
			cb(args[0], args[1])
		} else if len(args) > 0 {
			cb(args[0], nil)
		} else {
			cb(nil, nil)
		}
	default:
		// Unsupported callback type
		// In a real implementation, you might want to handle more types
		// or use reflection to call the function
	}
}

############################################################
# File: gtk4/box.go
############################################################

// Package gtk4 provides box layout functionality for GTK4
// File: gtk4go/gtk4/box.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// Orientation defines the orientation of a Box
type Orientation int

const (
	// OrientationHorizontal for horizontal layout
	OrientationHorizontal Orientation = C.GTK_ORIENTATION_HORIZONTAL
	// OrientationVertical for vertical layout
	OrientationVertical Orientation = C.GTK_ORIENTATION_VERTICAL
)

// BoxOption is a function that configures a box
type BoxOption func(*Box)

// Box represents a GTK box container
type Box struct {
	BaseWidget
}

// NewBox creates a new GTK box with the given orientation
func NewBox(orientation Orientation, spacing int, options ...BoxOption) *Box {
	box := &Box{
		BaseWidget: BaseWidget{
			widget: C.gtk_box_new(C.GtkOrientation(orientation), C.int(spacing)),
		},
	}

	// Apply options
	for _, option := range options {
		option(box)
	}

	SetupFinalization(box, box.Destroy)
	return box
}

// WithSpacing sets the spacing between children
func WithSpacing(spacing int) BoxOption {
	return func(b *Box) {
		C.gtk_box_set_spacing((*C.GtkBox)(unsafe.Pointer(b.widget)), C.int(spacing))
	}
}

// WithHomogeneous sets whether all children get the same space
func WithHomogeneous(homogeneous bool) BoxOption {
	return func(b *Box) {
		var chomogeneous C.gboolean
		if homogeneous {
			chomogeneous = C.TRUE
		} else {
			chomogeneous = C.FALSE
		}
		C.gtk_box_set_homogeneous((*C.GtkBox)(unsafe.Pointer(b.widget)), chomogeneous)
	}
}

// Append adds a widget to the end of the box
func (b *Box) Append(child Widget) {
	C.gtk_box_append((*C.GtkBox)(unsafe.Pointer(b.widget)), child.GetWidget())
}

// Prepend adds a widget to the start of the box
func (b *Box) Prepend(child Widget) {
	C.gtk_box_prepend((*C.GtkBox)(unsafe.Pointer(b.widget)), child.GetWidget())
}

// Remove removes a widget from the box
func (b *Box) Remove(child Widget) {
	C.gtk_box_remove((*C.GtkBox)(unsafe.Pointer(b.widget)), child.GetWidget())
}

// SetSpacing sets the spacing between children
func (b *Box) SetSpacing(spacing int) {
	C.gtk_box_set_spacing((*C.GtkBox)(unsafe.Pointer(b.widget)), C.int(spacing))
}

// SetHomogeneous sets whether all children get the same space
func (b *Box) SetHomogeneous(homogeneous bool) {
	var chomogeneous C.gboolean
	if homogeneous {
		chomogeneous = C.TRUE
	} else {
		chomogeneous = C.FALSE
	}
	C.gtk_box_set_homogeneous((*C.GtkBox)(unsafe.Pointer(b.widget)), chomogeneous)
}

// SetHExpand sets whether the box expands horizontally
func (b *Box) SetHExpand(expand bool) {
	var cexpand C.gboolean
	if expand {
		cexpand = C.TRUE
	} else {
		cexpand = C.FALSE
	}
	C.gtk_widget_set_hexpand(b.widget, cexpand)
}

// SetVExpand sets whether the box expands vertically
func (b *Box) SetVExpand(expand bool) {
	var cexpand C.gboolean
	if expand {
		cexpand = C.TRUE
	} else {
		cexpand = C.FALSE
	}
	C.gtk_widget_set_vexpand(b.widget, cexpand)
}

############################################################
# File: gtk4/button.go
############################################################

// Package gtk4 provides button functionality for GTK4
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// ButtonOption is a function that configures a button
type ButtonOption func(*Button)

// Button represents a GTK button
type Button struct {
	BaseWidget
}

// NewButton creates a new GTK button with the given label
func NewButton(label string, options ...ButtonOption) *Button {
	var widget *C.GtkWidget

	WithCString(label, func(cLabel *C.char) {
		widget = C.gtk_button_new_with_label(cLabel)
	})

	button := &Button{
		BaseWidget: BaseWidget{
			widget: widget,
		},
	}

	// Apply options
	for _, option := range options {
		option(button)
	}

	SetupFinalization(button, button.Destroy)
	return button
}

// WithMnemonic creates a button with mnemonic support
func WithMnemonic(label string) ButtonOption {
	return func(b *Button) {
		WithCString(label, func(cLabel *C.char) {
			b.widget = C.gtk_button_new_with_mnemonic(cLabel)
		})
	}
}

// SetLabel sets the button's label
func (b *Button) SetLabel(label string) {
	WithCString(label, func(cLabel *C.char) {
		C.gtk_button_set_label((*C.GtkButton)(unsafe.Pointer(b.widget)), cLabel)
	})
}

// GetLabel gets the button's label
func (b *Button) GetLabel() string {
	cLabel := C.gtk_button_get_label((*C.GtkButton)(unsafe.Pointer(b.widget)))
	if cLabel == nil {
		return ""
	}
	return C.GoString(cLabel)
}

// ConnectClicked connects a callback function to the button's "clicked" signal
func (b *Button) ConnectClicked(callback func()) {
	// Use the new callback system from callbacks.go
	Connect(b, SignalClicked, callback)
}

// DisconnectClicked disconnects all clicked signal handlers
func (b *Button) DisconnectClicked() {
	// Use the DisconnectAll function from the unified callback system
	// for the specific signal
	// TODO: If needed, we could add a method to the callback system to disconnect by signal
	DisconnectAll(b)
}

// Destroy destroys the button and cleans up resources
func (b *Button) Destroy() {
	// Disconnect all signals for this widget
	DisconnectAll(b)

	// Call base destroy method
	b.BaseWidget.Destroy()
}

// SetIconName sets the icon for the button
func (b *Button) SetIconName(iconName string) {
	WithCString(iconName, func(cIconName *C.char) {
		// Create a new image with the icon name
		image := C.gtk_image_new_from_icon_name(cIconName)

		// Set the image on the button
		C.gtk_button_set_child((*C.GtkButton)(unsafe.Pointer(b.widget)), image)
	})
}

// SetChild sets the child widget for the button (instead of a label)
func (b *Button) SetChild(child Widget) {
	C.gtk_button_set_child((*C.GtkButton)(unsafe.Pointer(b.widget)), child.GetWidget())
}

// GetChild gets the child widget of the button
func (b *Button) GetChild() Widget {
	widget := C.gtk_button_get_child((*C.GtkButton)(unsafe.Pointer(b.widget)))
	if widget == nil {
		return nil
	}

	// Create a BaseWidget wrapper for the child
	// Note: In a real implementation, we would determine the widget type
	return &BaseWidget{widget: widget}
}

// SetHasFrame sets whether the button has a visible frame
func (b *Button) SetHasFrame(hasFrame bool) {
	var cHasFrame C.gboolean
	if hasFrame {
		cHasFrame = C.TRUE
	} else {
		cHasFrame = C.FALSE
	}
	C.gtk_button_set_has_frame((*C.GtkButton)(unsafe.Pointer(b.widget)), cHasFrame)
}

// GetHasFrame gets whether the button has a visible frame
func (b *Button) GetHasFrame() bool {
	return C.gtk_button_get_has_frame((*C.GtkButton)(unsafe.Pointer(b.widget))) == C.TRUE
}



############################################################
# File: gtk4/callbacks.go
############################################################

// Package gtk4 provides a unified callback management system for GTK4 widgets
// File: gtk4go/gtk4/callbacks.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Exported callback functions (implemented in Go)
// extern void callbackHandler(GObject *object, gpointer data);
// extern void callbackHandlerWithParam(GObject *object, gpointer param, gpointer data);
// extern gboolean callbackHandlerWithReturn(GObject *object, gpointer data);
//
// // Generic function to connect a signal to a handler
// static gulong connectSignal(GObject *object, const char *signal, gboolean hasParam, gboolean hasReturn, guint callbackId) {
//     if (hasReturn) {
//         return g_signal_connect(object, signal, G_CALLBACK(callbackHandlerWithReturn), GUINT_TO_POINTER(callbackId));
//     } else if (hasParam) {
//         return g_signal_connect(object, signal, G_CALLBACK(callbackHandlerWithParam), GUINT_TO_POINTER(callbackId));
//     } else {
//         return g_signal_connect(object, signal, G_CALLBACK(callbackHandler), GUINT_TO_POINTER(callbackId));
//     }
// }
//
// // Function to disconnect a signal
// static void disconnectSignal(GObject *object, gulong handlerId) {
//     if (handlerId > 0) {
//         g_signal_handler_disconnect(object, handlerId);
//     }
// }
import "C"

import (
	"fmt"
	"reflect"
	"runtime"
	"sync"
	"sync/atomic"
	"unsafe"

	// Import the main package for UI thread execution

	gtk4go "../../gtk4go"
)

// SignalType represents the type of GTK signal
type SignalType string

// SignalSource represents the source of a signal (to distinguish between signals with the same name)
type SignalSource int

const (
	// Signal sources
	SourceGeneric SignalSource = iota
	SourceListView
	SourceAction
)

// Common GTK signal types
const (
	// Button signals
	SignalClicked SignalType = "clicked"

	// Entry signals
	SignalChanged  SignalType = "changed"
	SignalActivate SignalType = "activate"

	// Window signals
	SignalCloseRequest SignalType = "close-request"

	// Dialog signals
	SignalResponse SignalType = "response"

	// ListView signals - same name as action signal but different context
	SignalListActivate SignalType = "activate"

	// SelectionModel signals
	SignalSelectionChanged SignalType = "selection-changed"

	// Adjustment signals
	SignalValueChanged SignalType = "value-changed"

	// Action signals - same name as list signal but different context
	SignalActionActivate SignalType = "activate"
)

// nextCallbackID is a counter for generating unique callback IDs
var nextCallbackID atomic.Uint64

// CallbackManager handles GTK signal callbacks
type CallbackManager struct {
	// Map from callback ID to callback data
	callbacks sync.Map
	// Map from object pointer to list of handler IDs
	objectHandlers sync.Map
	// Map from object pointer to map of signal type to callback data
	objectCallbacks sync.Map
}

// callbackData stores information about a callback
type callbackData struct {
	callback  interface{}
	objectPtr uintptr
	signal    SignalType
	source    SignalSource // Added field to track signal source
	hasParam  bool
	hasReturn bool
	handlerID C.gulong
}

// Global callback manager
var globalCallbackManager = &CallbackManager{}

// EnableCallbackDebugging enables or disables debug output for callbacks
func EnableCallbackDebugging(enable bool) {
	if enable {
		EnableDebugComponent(DebugComponentCallback)
		SetDebugLevel(DebugLevelVerbose) // Set to verbose level for detailed callback info
	} else {
		DisableDebugComponent(DebugComponentCallback)
	}
}

// Connect connects a signal to a callback function
func Connect(object interface{}, signal SignalType, callback interface{}) (handlerID uint64) {
	// Get the object's pointer
	objectPtr := getObjectPointer(object)
	if objectPtr == 0 {
		DebugLog(DebugLevelError, DebugComponentCallback, "Connect failed: couldn't get object pointer for %T", object)
		return 0 // Invalid object
	}

	// Generate a unique ID for this callback
	id := nextCallbackID.Add(1)

	// Check callback signature to determine parameter and return type
	hasParam, hasReturn := analyzeCallbackSignature(callback)

	// Determine signal source based on object type and signal
	source := SourceGeneric
	if _, isListView := object.(*ListView); isListView && signal == SignalListActivate {
		source = SourceListView
	} else if _, isAction := object.(*Action); isAction && signal == SignalActionActivate {
		source = SourceAction
	}

	// Create callback data
	data := &callbackData{
		callback:  callback,
		objectPtr: objectPtr,
		signal:    signal,
		source:    source,
		hasParam:  hasParam,
		hasReturn: hasReturn,
		handlerID: 0, // Will be set after connection
	}

	// Connect the signal
	cObject := (*C.GObject)(unsafe.Pointer(objectPtr))
	cSignal := C.CString(string(signal))
	defer C.free(unsafe.Pointer(cSignal))

	// Connect and get handler ID
	handlerId := C.connectSignal(
		cObject,
		cSignal,
		boolToGBoolean(hasParam),
		boolToGBoolean(hasReturn),
		C.guint(id),
	)

	// Store the handler ID in the callback data
	data.handlerID = handlerId

	// Store the callback data in the map
	globalCallbackManager.callbacks.Store(id, data)

	// Associate this handler with the object for cleanup
	globalCallbackManager.trackObjectHandler(objectPtr, handlerId)

	// Store callback by object and signal for direct lookups
	globalCallbackManager.storeObjectCallback(objectPtr, signal, callback)

	DebugLog(DebugLevelInfo, DebugComponentCallback, "Connected signal %s with ID %d to object %p (source: %d)",
		signal, id, objectPtr, source)

	return id
}

// Disconnect disconnects a signal handler by its ID
func Disconnect(id uint64) {
	// Look up the callback data
	value, ok := globalCallbackManager.callbacks.Load(id)
	if !ok {
		DebugLog(DebugLevelWarning, DebugComponentCallback, "Disconnect failed: callback ID %d not found", id)
		return
	}

	data := value.(*callbackData)

	// Disconnect the signal
	cObject := (*C.GObject)(unsafe.Pointer(data.objectPtr))
	C.disconnectSignal(cObject, data.handlerID)

	// Remove the callback from the maps
	globalCallbackManager.callbacks.Delete(id)
	globalCallbackManager.removeObjectCallback(data.objectPtr, data.signal)

	// Remove the handler from the object's handler list
	globalCallbackManager.untrackObjectHandler(data.objectPtr, data.handlerID)

	DebugLog(DebugLevelInfo, DebugComponentCallback, "Disconnected signal handler ID %d from object %p", id, data.objectPtr)
}

// DisconnectAll disconnects all signal handlers for an object
func DisconnectAll(object interface{}) {
	objectPtr := getObjectPointer(object)
	if objectPtr == 0 {
		DebugLog(DebugLevelWarning, DebugComponentCallback, "DisconnectAll failed: couldn't get object pointer for %T", object)
		return
	}

	// Get the object's handlers
	value, ok := globalCallbackManager.objectHandlers.Load(objectPtr)
	if !ok {
		DebugLog(DebugLevelVerbose, DebugComponentCallback, "DisconnectAll: no handlers found for object %p", objectPtr)
		return
	}

	handlers := value.([]C.gulong)

	// Disconnect each handler
	cObject := (*C.GObject)(unsafe.Pointer(objectPtr))
	for _, handlerId := range handlers {
		C.disconnectSignal(cObject, handlerId)
		DebugLog(DebugLevelVerbose, DebugComponentCallback, "DisconnectAll: disconnected handler ID %d from object %p", handlerId, objectPtr)
	}

	// Remove the object from the maps
	globalCallbackManager.objectHandlers.Delete(objectPtr)
	globalCallbackManager.objectCallbacks.Delete(objectPtr)

	// Remove all callbacks for this object from the callbacks map
	globalCallbackManager.callbacks.Range(func(key, value interface{}) bool {
		data := value.(*callbackData)
		if data.objectPtr == objectPtr {
			globalCallbackManager.callbacks.Delete(key)
			DebugLog(DebugLevelVerbose, DebugComponentCallback, "DisconnectAll: removed callback ID %d from object %p", key, objectPtr)
		}
		return true
	})
}

// GetCallback retrieves a callback for a specific object and signal
func GetCallback(objectPtr uintptr, signal SignalType) interface{} {
	objectCallbacksValue, ok := globalCallbackManager.objectCallbacks.Load(objectPtr)
	if !ok {
		return nil
	}

	objectCallbacks := objectCallbacksValue.(map[SignalType]interface{})
	callback, ok := objectCallbacks[signal]
	if !ok {
		return nil
	}

	return callback
}

// storeObjectCallback stores a callback by object pointer and signal type
func (m *CallbackManager) storeObjectCallback(objectPtr uintptr, signal SignalType, callback interface{}) {
	objectCallbacksValue, ok := m.objectCallbacks.Load(objectPtr)
	var objectCallbacks map[SignalType]interface{}

	if !ok {
		objectCallbacks = make(map[SignalType]interface{})
	} else {
		objectCallbacks = objectCallbacksValue.(map[SignalType]interface{})
	}

	objectCallbacks[signal] = callback
	m.objectCallbacks.Store(objectPtr, objectCallbacks)
}

// removeObjectCallback removes a callback by object pointer and signal type
func (m *CallbackManager) removeObjectCallback(objectPtr uintptr, signal SignalType) {
	objectCallbacksValue, ok := m.objectCallbacks.Load(objectPtr)
	if !ok {
		return
	}

	objectCallbacks := objectCallbacksValue.(map[SignalType]interface{})
	delete(objectCallbacks, signal)

	if len(objectCallbacks) == 0 {
		m.objectCallbacks.Delete(objectPtr)
	} else {
		m.objectCallbacks.Store(objectPtr, objectCallbacks)
	}
}

// getObjectPointer returns the pointer to the GObject of a GTK widget
func getObjectPointer(object interface{}) uintptr {
	// Handle common GTK widget types
	switch obj := object.(type) {
	case Widget:
		return uintptr(unsafe.Pointer(obj.GetWidget()))
	case *Adjustment:
		return uintptr(unsafe.Pointer(obj.adjustment))
	case *Action:
		return uintptr(unsafe.Pointer(obj.action))
	default:
		// Try to find a GetWidget or Native method using reflection
		val := reflect.ValueOf(object)
		if val.Kind() == reflect.Ptr && !val.IsNil() {
			// Try GetWidget method
			getWidgetMethod := val.MethodByName("GetWidget")
			if getWidgetMethod.IsValid() {
				results := getWidgetMethod.Call(nil)
				if len(results) == 1 {
					return uintptr(unsafe.Pointer(results[0].Pointer()))
				}
			}

			// Try Native method
			nativeMethod := val.MethodByName("Native")
			if nativeMethod.IsValid() {
				results := nativeMethod.Call(nil)
				if len(results) == 1 && results[0].Kind() == reflect.Uintptr {
					// Convert uint64 to uintptr safely, even on 32-bit systems
					return uintptr(results[0].Interface().(uintptr))
				}
			}
		}
	}

	return 0 // Unable to get pointer
}

// analyzeCallbackSignature determines if a callback takes parameters or returns a value
func analyzeCallbackSignature(callback interface{}) (hasParam bool, hasReturn bool) {
	// Get the type of the callback
	callbackType := reflect.TypeOf(callback)

	// Must be a function
	if callbackType.Kind() != reflect.Func {
		return false, false
	}

	// Check if it has parameters
	hasParam = callbackType.NumIn() > 0

	// Check if it has a return value
	hasReturn = callbackType.NumOut() > 0

	return hasParam, hasReturn
}

// trackObjectHandler associates a handler ID with an object
func (m *CallbackManager) trackObjectHandler(objectPtr uintptr, handlerId C.gulong) {
	value, ok := m.objectHandlers.Load(objectPtr)
	var handlers []C.gulong
	if ok {
		handlers = value.([]C.gulong)
	} else {
		handlers = make([]C.gulong, 0, 4) // Pre-allocate space for 4 handlers
	}

	handlers = append(handlers, handlerId)
	m.objectHandlers.Store(objectPtr, handlers)

	DebugLog(DebugLevelVerbose, DebugComponentCallback, "Tracked handler ID %d for object %p", handlerId, objectPtr)
}

// untrackObjectHandler removes a handler ID from an object
func (m *CallbackManager) untrackObjectHandler(objectPtr uintptr, handlerId C.gulong) {
	value, ok := m.objectHandlers.Load(objectPtr)
	if !ok {
		DebugLog(DebugLevelVerbose, DebugComponentCallback, "untrackObjectHandler: no handlers found for object %p", objectPtr)
		return
	}

	handlers := value.([]C.gulong)

	// Find and remove the handler
	for i, id := range handlers {
		if id == handlerId {
			// Remove by swapping with the last element and slicing
			handlers[i] = handlers[len(handlers)-1]
			handlers = handlers[:len(handlers)-1]
			break
		}
	}

	if len(handlers) == 0 {
		// No more handlers for this object
		m.objectHandlers.Delete(objectPtr)
		DebugLog(DebugLevelVerbose, DebugComponentCallback, "untrackObjectHandler: removed last handler for object %p", objectPtr)
	} else {
		m.objectHandlers.Store(objectPtr, handlers)
		DebugLog(DebugLevelVerbose, DebugComponentCallback, "untrackObjectHandler: %d handlers remaining for object %p", len(handlers), objectPtr)
	}
}

// boolToGBoolean converts a Go bool to a C gboolean
func boolToGBoolean(b bool) C.gboolean {
	if b {
		return C.TRUE
	}
	return C.FALSE
}

// execCallback safely executes a callback on the main UI thread
// to ensure thread safety with GTK
func execCallback(callback interface{}, args ...interface{}) {
	// Execute on UI thread to ensure GTK thread safety
	gtk4go.RunOnUIThread(func() {
		// Execute the callback based on its type
		switch cb := callback.(type) {
		case func():
			cb()
		case func(int):
			if len(args) > 0 {
				if i, ok := args[0].(int); ok {
					cb(i)
				}
			}
		case func(ResponseType):
			if len(args) > 0 {
				if rt, ok := args[0].(ResponseType); ok {
					cb(rt)
				}
			}
		case func() bool:
			cb()
		case func(int, int):
			if len(args) > 1 {
				if i1, ok1 := args[0].(int); ok1 {
					if i2, ok2 := args[1].(int); ok2 {
						cb(i1, i2)
					}
				}
			}
		default:
			DebugLog(DebugLevelError, DebugComponentCallback, "Unsupported callback type: %T", callback)
		}
	})
}

// Exported callback functions for CGo

//export callbackHandler
func callbackHandler(object *C.GObject, data C.gpointer) {
	id := uint64(uintptr(data))
	value, ok := globalCallbackManager.callbacks.Load(id)
	if !ok {
		DebugLog(DebugLevelWarning, DebugComponentCallback, "callbackHandler: callback ID %d not found", id)
		return
	}

	callbackData := value.(*callbackData)
	DebugLog(DebugLevelVerbose, DebugComponentCallback, "callbackHandler: executing callback ID %d for signal %s", id, callbackData.signal)

	// Call the callback with no parameters on the UI thread
	if callback, ok := callbackData.callback.(func()); ok {
		execCallback(callback)
	} else {
		DebugLog(DebugLevelError, DebugComponentCallback, "callbackHandler: callback has wrong type: %T", callbackData.callback)
	}
}

//export callbackHandlerWithParam
func callbackHandlerWithParam(object *C.GObject, param C.gpointer, data C.gpointer) {
	id := uint64(uintptr(data))
	value, ok := globalCallbackManager.callbacks.Load(id)
	if !ok {
		DebugLog(DebugLevelWarning, DebugComponentCallback, "callbackHandlerWithParam: callback ID %d not found", id)
		return
	}

	callbackData := value.(*callbackData)
	paramVal := int(uintptr(param))
	DebugLog(DebugLevelVerbose, DebugComponentCallback, "callbackHandlerWithParam: executing callback ID %d for signal %s with param %v (source: %d)",
		id, callbackData.signal, paramVal, callbackData.source)

	// Handle different callback signatures based on the signal type and source
	switch {
	case callbackData.signal == SignalResponse:
		// For dialog responses, param is the response ID
		if callback, ok := callbackData.callback.(func(ResponseType)); ok {
			execCallback(callback, ResponseType(uintptr(param)))
		}

	case callbackData.signal == SignalSelectionChanged:
		// For selection changed, we have position and count
		if callback, ok := callbackData.callback.(func(int)); ok {
			execCallback(callback, paramVal)
		} else if callback, ok := callbackData.callback.(func(int, int)); ok {
			// In a real implementation, you'd extract both position and count
			execCallback(callback, paramVal, 0)
		}

	case callbackData.signal == SignalListActivate && callbackData.source == SourceListView:
		// For ListView activation - check for multiple possible types
		// First try direct function type
		if callback, ok := callbackData.callback.(func(int)); ok {
			DebugLog(DebugLevelInfo, DebugComponentListView, 
				"Executing list activate callback for position %d", paramVal)
			execCallback(callback, paramVal)
		} else if callback, ok := callbackData.callback.(ListViewActivateCallback); ok {
			// Then try the specific callback type
			DebugLog(DebugLevelInfo, DebugComponentListView, 
				"Executing ListViewActivateCallback for position %d", paramVal)
			execCallback(func(pos int) {
				callback(pos)
			}, paramVal)
		} else {
			// Log error if neither type matches
			DebugLog(DebugLevelError, DebugComponentListView,
				"ListActivate callback has wrong type: %T, expected func(int) or ListViewActivateCallback", 
				callbackData.callback)
		}
		
	case callbackData.signal == SignalActionActivate && callbackData.source == SourceAction:
		// For Action activation
		if callback, ok := callbackData.callback.(func()); ok {
			DebugLog(DebugLevelInfo, DebugComponentAction, 
				"Executing action activate callback")
			execCallback(callback)
		} else {
			DebugLog(DebugLevelError, DebugComponentAction,
				"ActionActivate callback has wrong type: %T, expected func()", callbackData.callback)
		}
		
	case callbackData.signal == SignalActivate:
		// For general activation (Entry, etc)
		if callback, ok := callbackData.callback.(func()); ok {
			execCallback(callback)
		} else {
			DebugLog(DebugLevelError, DebugComponentCallback,
				"Activate callback has wrong type: %T, expected func()", callbackData.callback)
		}
		
	default:
		// For other cases, try to call with an int parameter
		if callback, ok := callbackData.callback.(func(int)); ok {
			execCallback(callback, paramVal)
		} else if callback, ok := callbackData.callback.(func(interface{})); ok {
			// For callbacks that accept any parameter
			execCallback(callback, paramVal)
		} else if callback, ok := callbackData.callback.(func()); ok {
			// Try no parameter callback as last resort
			execCallback(callback)
		} else {
			DebugLog(DebugLevelError, DebugComponentCallback, 
				"callbackHandlerWithParam: callback has wrong type: %T", callbackData.callback)
		}
	}
}

//export callbackHandlerWithReturn
func callbackHandlerWithReturn(object *C.GObject, data C.gpointer) C.gboolean {
	id := uint64(uintptr(data))
	value, ok := globalCallbackManager.callbacks.Load(id)
	if !ok {
		DebugLog(DebugLevelWarning, DebugComponentCallback, "callbackHandlerWithReturn: callback ID %d not found", id)
		return C.FALSE
	}

	callbackData := value.(*callbackData)
	DebugLog(DebugLevelVerbose, DebugComponentCallback, "callbackHandlerWithReturn: executing callback ID %d for signal %s", id, callbackData.signal)

	// Callbacks with return values need to be executed synchronously
	// to get the return value back to C
	if callback, ok := callbackData.callback.(func() bool); ok {
		// Since we need the return value, we can't use execCallback here
		// Ideally, this should still ensure we're on the UI thread
		result := callback()
		if result {
			return C.TRUE
		}
	} else {
		DebugLog(DebugLevelError, DebugComponentCallback, "callbackHandlerWithReturn: callback has wrong type: %T", callbackData.callback)
	}

	return C.FALSE
}

// Initialize the callback system
func init() {
	// Register a finalizer to clean up all callbacks at exit
	runtime.SetFinalizer(globalCallbackManager, func(m *CallbackManager) {
		// Disconnect all signals
		m.callbacks.Range(func(key, value interface{}) bool {
			data := value.(*callbackData)
			cObject := (*C.GObject)(unsafe.Pointer(data.objectPtr))
			C.disconnectSignal(cObject, data.handlerID)
			return true
		})
	})
}

// GetCallbackStats returns statistics about the callback system
func GetCallbackStats() map[string]int {
	stats := make(map[string]int)

	// Count callbacks
	callbackCount := 0
	globalCallbackManager.callbacks.Range(func(_, _ interface{}) bool {
		callbackCount++
		return true
	})
	stats["TotalCallbacks"] = callbackCount

	// Count objects with handlers
	objectCount := 0
	globalCallbackManager.objectHandlers.Range(func(_, _ interface{}) bool {
		objectCount++
		return true
	})
	stats["ObjectsWithCallbacks"] = objectCount

	// Count callback types by signal
	signalCounts := make(map[SignalType]int)
	globalCallbackManager.callbacks.Range(func(_, value interface{}) bool {
		data := value.(*callbackData)
		signalCounts[data.signal]++
		return true
	})

	for signal, count := range signalCounts {
		stats[fmt.Sprintf("Signal_%s", signal)] = count
	}

	return stats
}

// Note: StoreDirectCallback and SafeCallback are already defined in action.go and base.go respectively
// They have been removed from this file to fix duplicate declarations

############################################################
# File: gtk4/css.go
############################################################

// Package gtk4 provides CSS styling functionality for GTK4
// File: gtk4go/gtk4/css.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Helper to convert Go string to CSS string
// static void _go_css_provider_load_from_string(GtkCssProvider *provider, const char *css_string) {
//     gtk_css_provider_load_from_string(provider, css_string);
// }
//
// // Helper to mark CSS provider for optimization
// static void _go_css_provider_set_optimization(GtkCssProvider *provider, gboolean optimize) {
//     g_object_set_data(G_OBJECT(provider), "optimize-rendering", GINT_TO_POINTER(optimize ? 1 : 0));
// }
import "C"

import (
	"os"
	"runtime"
	"sync"
	"unsafe"
)

// Global CSS provider cache to avoid recreating providers
var (
	// Cache CSS providers by content
	cssProviderCache = make(map[string]*CSSProvider)
	cssProviderMutex sync.RWMutex

	// Track global providers for optimization
	globalProviders     = make([]*CSSProvider, 0, 5)
	globalProviderMutex sync.RWMutex

	// Lightweight CSS for resize operations
	resizeCSSProvider *CSSProvider
)

func init() {
	// Create a lightweight CSS provider for resize operations
	initResizeCSS := `
		/* Minimal CSS during resize - only essential rules */
		window, dialog { background-color: #f5f5f5; }
		button { padding: 2px; }
		entry { padding: 2px; }
		label { padding: 0; }
	`
	var err error
	resizeCSSProvider, err = loadCSS(initResizeCSS)
	if err != nil {
		// Fall back to empty provider if there's an error
		resizeCSSProvider = newCSSProvider()
	}
}

// CSSProvider represents a GTK CSS provider
type CSSProvider struct {
	provider *C.GtkCssProvider
	cssData  string // Store original CSS for cache lookups
}

// newCSSProvider creates a new GTK CSS provider
func newCSSProvider() *CSSProvider {
	provider := &CSSProvider{
		provider: C.gtk_css_provider_new(),
	}
	runtime.SetFinalizer(provider, (*CSSProvider).free)
	return provider
}

// loadFromData loads CSS data from a string
func (p *CSSProvider) loadFromData(cssData string) error {
	// Store the CSS data for cache lookups
	p.cssData = cssData

	cCssData := C.CString(cssData)
	defer C.free(unsafe.Pointer(cCssData))

	// Use the helper function that calls the GTK4 API
	C._go_css_provider_load_from_string(p.provider, cCssData)
	return nil
}

// loadFromFile loads CSS data from a file
func (p *CSSProvider) loadFromFile(filepath string) error {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return err
	}
	return p.loadFromData(string(data))
}

// free frees the CSS provider
func (p *CSSProvider) free() {
	if p.provider != nil {
		// Remove from global providers list if present
		globalProviderMutex.Lock()
		for i, provider := range globalProviders {
			if provider == p {
				// Remove without preserving order
				globalProviders[i] = globalProviders[len(globalProviders)-1]
				globalProviders = globalProviders[:len(globalProviders)-1]
				break
			}
		}
		globalProviderMutex.Unlock()

		// Remove from cache if present
		if p.cssData != "" {
			cssProviderMutex.Lock()
			delete(cssProviderCache, p.cssData)
			cssProviderMutex.Unlock()
		}

		C.g_object_unref(C.gpointer(unsafe.Pointer(p.provider)))
		p.provider = nil
	}
}

// setOptimization enables or disables rendering optimization for this provider
func (p *CSSProvider) setOptimization(optimize bool) {
	var cOptimize C.gboolean
	if optimize {
		cOptimize = C.TRUE
	} else {
		cOptimize = C.FALSE
	}
	C._go_css_provider_set_optimization(p.provider, cOptimize)
}

// optimizeAllProviders enables optimization for all global CSS providers
func optimizeAllProviders() {
	globalProviderMutex.RLock()
	providers := make([]*CSSProvider, len(globalProviders))
	copy(providers, globalProviders)
	globalProviderMutex.RUnlock()

	for _, provider := range providers {
		provider.setOptimization(true)
	}
}

// resetAllProviders disables optimization for all global CSS providers
func resetAllProviders() {
	globalProviderMutex.RLock()
	providers := make([]*CSSProvider, len(globalProviders))
	copy(providers, globalProviders)
	globalProviderMutex.RUnlock()

	for _, provider := range providers {
		provider.setOptimization(false)
	}
}

// useResizeCSSProvider temporarily switches to a lightweight CSS provider during resize
func useResizeCSSProvider(display *C.GdkDisplay) *C.GtkCssProvider {
	if display == nil {
		display = C.gdk_display_get_default()
	}

	// Instead of trying to get the existing provider, we'll just
	// add our lightweight provider with a higher priority
	if resizeCSSProvider != nil {
		C.gtk_style_context_add_provider_for_display(display,
			(*C.GtkStyleProvider)(unsafe.Pointer(resizeCSSProvider.provider)),
			C.guint(priorityResize)) // Higher priority
	}

	// Return nil since we can't get the original provider directly
	return nil
}

// restoreOriginalCSSProvider restores the CSS after resize
func restoreOriginalCSSProvider(display *C.GdkDisplay, original *C.GtkCssProvider) {
	if display == nil {
		display = C.gdk_display_get_default()
	}

	// Just remove the resize provider
	if resizeCSSProvider != nil {
		C.gtk_style_context_remove_provider_for_display(display,
			(*C.GtkStyleProvider)(unsafe.Pointer(resizeCSSProvider.provider)))
	}

	// We don't need to restore the original provider since we never removed it,
	// we just temporarily added a higher-priority provider
}

// AddProviderForDisplay adds a CSS provider to the default display
func AddProviderForDisplay(provider *CSSProvider, priority uint) {
	display := C.gdk_display_get_default()
	C.gtk_style_context_add_provider_for_display(display,
		(*C.GtkStyleProvider)(unsafe.Pointer(provider.provider)),
		C.guint(priority))

	// Add to global providers list for optimization
	globalProviderMutex.Lock()
	globalProviders = append(globalProviders, provider)
	globalProviderMutex.Unlock()
}

// Widget CSS class methods - using modern GTK4 API

// AddStyleClass adds a CSS class to a widget
func AddStyleClass(widget interface{}, className string) {
	if w, ok := widget.(interface{ GetWidget() *C.GtkWidget }); ok {
		cClassName := C.CString(className)
		defer C.free(unsafe.Pointer(cClassName))
		C.gtk_widget_add_css_class(w.GetWidget(), cClassName)
	}
}

// RemoveStyleClass removes a CSS class from a widget
func RemoveStyleClass(widget interface{}, className string) {
	if w, ok := widget.(interface{ GetWidget() *C.GtkWidget }); ok {
		cClassName := C.CString(className)
		defer C.free(unsafe.Pointer(cClassName))
		C.gtk_widget_remove_css_class(w.GetWidget(), cClassName)
	}
}

// HasStyleClass checks if a widget has a CSS class
func HasStyleClass(widget interface{}, className string) bool {
	if w, ok := widget.(interface{ GetWidget() *C.GtkWidget }); ok {
		cClassName := C.CString(className)
		defer C.free(unsafe.Pointer(cClassName))
		return C.gtk_widget_has_css_class(w.GetWidget(), cClassName) == 1
	}
	return false
}

// StylePriority defines the priority levels for CSS providers
type StylePriority uint

const (
	// priorityApplication is the priority for application-specific styles
	priorityApplication StylePriority = 600
	// priorityUser is the priority for user-specific styles
	priorityUser StylePriority = 800
	// priorityTheme is the priority for theme styles
	priorityTheme StylePriority = 400
	// prioritySetting is the priority for settings styles
	prioritySetting StylePriority = 500
	// priorityFallback is the priority for fallback styles
	priorityFallback StylePriority = 1
	// priorityResize is a higher priority used during resize operations
	priorityResize StylePriority = 900
)

// loadCSS is a convenience function to create a provider and load CSS from a string with caching
func loadCSS(cssData string) (*CSSProvider, error) {
	// Check cache first
	cssProviderMutex.RLock()
	provider, exists := cssProviderCache[cssData]
	cssProviderMutex.RUnlock()

	if exists {
		return provider, nil
	}

	// Create new provider if not in cache
	provider = newCSSProvider()
	err := provider.loadFromData(cssData)
	if err != nil {
		return nil, err
	}

	// Store in cache
	cssProviderMutex.Lock()
	cssProviderCache[cssData] = provider
	cssProviderMutex.Unlock()

	return provider, nil
}

// LoadCSS is a public convenience function to create a provider and load CSS from a string
func LoadCSS(cssData string) (*CSSProvider, error) {
	return loadCSS(cssData)
}

// LoadCSSFromFile is a convenience function to create a provider and load CSS from a file
func LoadCSSFromFile(filepath string) (*CSSProvider, error) {
	data, err := os.ReadFile(filepath)
	if err != nil {
		return nil, err
	}
	return loadCSS(string(data))
}


############################################################
# File: gtk4/debug.go
############################################################

// Package gtk4 provides debugging utilities for GTK4 components
// File: gtk4go/gtk4/debug.go
package gtk4

import (
	"fmt"
	"log"
	"sync"
)

// Debug logging levels
const (
	DebugLevelNone    = 0 // No debug output
	DebugLevelError   = 1 // Error messages only
	DebugLevelWarning = 2 // Warnings and errors
	DebugLevelInfo    = 3 // Informational messages
	DebugLevelVerbose = 4 // Verbose output
)

// Component identifiers for filtering debug output
const (
	DebugComponentGeneral     = "general"
	DebugComponentCallback    = "callback"
	DebugComponentDialog      = "dialog"
	DebugComponentListView    = "listview"
	DebugComponentListFactory = "listfactory"
	DebugComponentAction      = "action"
	DebugComponentSelection   = "selection"
)

// Global debug configuration
var (
	debugLevel         = DebugLevelNone
	debugFilter        = make(map[string]bool)
	debugLogPrefix     = "[GTK4Go] "
	debugMutex         sync.RWMutex
	debugToStdErr      = false
)

// SetDebugLevel sets the global debug level
func SetDebugLevel(level int) {
	debugMutex.Lock()
	defer debugMutex.Unlock()
	debugLevel = level
}

// GetDebugLevel gets the current debug level
func GetDebugLevel() int {
	debugMutex.RLock()
	defer debugMutex.RUnlock()
	return debugLevel
}

// EnableComponent enables debug output for a specific component
func EnableDebugComponent(component string) {
	debugMutex.Lock()
	defer debugMutex.Unlock()
	debugFilter[component] = true
}

// DisableComponent disables debug output for a specific component
func DisableDebugComponent(component string) {
	debugMutex.Lock()
	defer debugMutex.Unlock()
	debugFilter[component] = false
}

// EnableAllComponents enables debug output for all components
func EnableAllDebugComponents() {
	debugMutex.Lock()
	defer debugMutex.Unlock()
	// Add all known components
	debugFilter[DebugComponentGeneral] = true
	debugFilter[DebugComponentCallback] = true
	debugFilter[DebugComponentDialog] = true
	debugFilter[DebugComponentListView] = true
	debugFilter[DebugComponentListFactory] = true
	debugFilter[DebugComponentAction] = true
	debugFilter[DebugComponentSelection] = true
}

// SetDebugToStdErr sets whether debug output should go to stderr
func SetDebugToStdErr(useStdErr bool) {
	debugMutex.Lock()
	defer debugMutex.Unlock()
	debugToStdErr = useStdErr
}

// DebugLog logs a debug message if the current level is high enough
// and the component is enabled for debugging
func DebugLog(level int, component string, format string, args ...interface{}) {
	debugMutex.RLock()
	currentLevel := debugLevel
	isComponentEnabled, exists := debugFilter[component]
	useStdErr := debugToStdErr
	debugMutex.RUnlock()

	// Only log if the level is appropriate and component is enabled (or not explicitly disabled)
	if level <= currentLevel && (isComponentEnabled || !exists) {
		message := fmt.Sprintf(format, args...)
		logMessage := fmt.Sprintf("%s[%s] %s", debugLogPrefix, component, message)
		
		if useStdErr {
			log.Printf("%s\n", logMessage)
		} else {
			fmt.Printf("%s\n", logMessage)
		}
	}
}

############################################################
# File: gtk4/dialog.go
############################################################

// Package gtk4 provides dialog functionality for GTK4
// File: gtk4go/gtk4/dialog.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// extern void buttonResponseCallback(GtkButton *button, gpointer user_data);
// extern gboolean windowCloseCallback(GtkWindow *window, gpointer user_data);
//
// static void connectButtonResponse(GtkButton *button, int response_id, gpointer dialog_ptr) {
//     // Store response ID as object data on the button
//     g_object_set_data(G_OBJECT(button), "response-id", GINT_TO_POINTER(response_id));
//
//     // Store dialog pointer as object data on the button
//     g_object_set_data(G_OBJECT(button), "dialog-ptr", dialog_ptr);
//
//     // Connect the clicked signal
//     g_signal_connect(button, "clicked", G_CALLBACK(buttonResponseCallback), button);
// }
//
// static void connectWindowClose(GtkWindow *window) {
//     g_signal_connect(window, "close-request", G_CALLBACK(windowCloseCallback), window);
// }
import "C"

import (
	"sync"
	"unsafe"
)

// ResponseType defines standard response IDs
type ResponseType int

const (
	// ResponseNone no response
	ResponseNone ResponseType = C.GTK_RESPONSE_NONE
	// ResponseReject reject the dialog
	ResponseReject ResponseType = C.GTK_RESPONSE_REJECT
	// ResponseAccept accept the dialog
	ResponseAccept ResponseType = C.GTK_RESPONSE_ACCEPT
	// ResponseDeleteEvent dialog was deleted
	ResponseDeleteEvent ResponseType = C.GTK_RESPONSE_DELETE_EVENT
	// ResponseOk affirmative response
	ResponseOk ResponseType = C.GTK_RESPONSE_OK
	// ResponseCancel negative response
	ResponseCancel ResponseType = C.GTK_RESPONSE_CANCEL
	// ResponseClose close response
	ResponseClose ResponseType = C.GTK_RESPONSE_CLOSE
	// ResponseYes yes response
	ResponseYes ResponseType = C.GTK_RESPONSE_YES
	// ResponseNo no response
	ResponseNo ResponseType = C.GTK_RESPONSE_NO
	// ResponseApply apply response
	ResponseApply ResponseType = C.GTK_RESPONSE_APPLY
	// ResponseHelp help response
	ResponseHelp ResponseType = C.GTK_RESPONSE_HELP
)

// DialogFlags defines behavior flags for dialogs
type DialogFlags int

const (
	// DialogModal makes the dialog modal
	DialogModal DialogFlags = 1 << 0
	// DialogDestroyWithParent destroys the dialog when its parent is destroyed
	DialogDestroyWithParent DialogFlags = 1 << 1
	// DialogUseHeaderBar uses a header bar for the dialog
	DialogUseHeaderBar DialogFlags = 1 << 2
)

// DialogResponseCallback represents a callback for dialog response events
type DialogResponseCallback func(responseId ResponseType)

var (
	dialogCallbacks     = make(map[uintptr]DialogResponseCallback)
	dialogCallbackMutex sync.RWMutex
)

//export buttonResponseCallback
func buttonResponseCallback(button *C.GtkButton, userData C.gpointer) {
	// Get response ID from button data
	responsePtr := C.g_object_get_data((*C.GObject)(unsafe.Pointer(button)), C.CString("response-id"))
	responseId := ResponseType(uintptr(responsePtr))

	// Get dialog pointer from button data
	dialogPtr := uintptr(C.g_object_get_data((*C.GObject)(unsafe.Pointer(button)), C.CString("dialog-ptr")))

	DebugLog(DebugLevelVerbose, DebugComponentDialog, "Button clicked with response %d for dialog %v", responseId, dialogPtr)

	// Look up callback
	dialogCallbackMutex.RLock()
	callback, exists := dialogCallbacks[dialogPtr]
	dialogCallbackMutex.RUnlock()

	if exists {
		// Execute callback in main thread, not in a separate goroutine
		callback(responseId)
	}
}

//export windowCloseCallback
func windowCloseCallback(window *C.GtkWindow, userData C.gpointer) C.gboolean {
	windowPtr := uintptr(unsafe.Pointer(window))
	DebugLog(DebugLevelVerbose, DebugComponentDialog, "Window close request for %v", windowPtr)

	// Look up callback
	dialogCallbackMutex.RLock()
	callback, exists := dialogCallbacks[windowPtr]
	dialogCallbackMutex.RUnlock()

	if exists {
		// Execute callback in main thread
		callback(ResponseDeleteEvent)
	}

	// Return FALSE to allow the window to close
	return C.FALSE
}

// Dialog represents a GTK dialog
type Dialog struct {
	Window
	buttonArea  *Box
	contentArea *Box
}

// NewDialog creates a new dialog
func NewDialog(title string, parent *Window, flags DialogFlags) *Dialog {
	// Create base window
	window := NewWindow(title)

	// Set modal and transient parent
	if flags&DialogModal != 0 {
		C.gtk_window_set_modal((*C.GtkWindow)(unsafe.Pointer(window.widget)), C.TRUE)
	}

	if parent != nil {
		C.gtk_window_set_transient_for(
			(*C.GtkWindow)(unsafe.Pointer(window.widget)),
			(*C.GtkWindow)(unsafe.Pointer(parent.widget)),
		)
	}

	if flags&DialogDestroyWithParent != 0 {
		C.gtk_window_set_destroy_with_parent(
			(*C.GtkWindow)(unsafe.Pointer(window.widget)),
			C.TRUE,
		)
	}

	// Create a dialog
	dialog := &Dialog{
		Window: *window,
	}

	// Connect window close handler
	C.connectWindowClose((*C.GtkWindow)(unsafe.Pointer(window.widget)))

	// Create a box for content
	mainBox := NewBox(OrientationVertical, 0)

	// Create content area
	dialog.contentArea = NewBox(OrientationVertical, 10)
	dialog.contentArea.AddCssClass("dialog-content-area")

	// Create button area
	dialog.buttonArea = NewBox(OrientationHorizontal, 6)
	dialog.buttonArea.AddCssClass("dialog-button-area")

	// Set up the button area for dialog buttons
	dialog.buttonArea.SetHomogeneous(false)
	C.gtk_widget_set_halign(dialog.buttonArea.widget, C.GTK_ALIGN_END)

	// Add padding
	C.gtk_widget_set_margin_start(dialog.contentArea.widget, 16)
	C.gtk_widget_set_margin_end(dialog.contentArea.widget, 16)
	C.gtk_widget_set_margin_top(dialog.contentArea.widget, 16)
	C.gtk_widget_set_margin_bottom(dialog.contentArea.widget, 16)

	C.gtk_widget_set_margin_start(dialog.buttonArea.widget, 16)
	C.gtk_widget_set_margin_end(dialog.buttonArea.widget, 16)
	C.gtk_widget_set_margin_top(dialog.buttonArea.widget, 10)
	C.gtk_widget_set_margin_bottom(dialog.buttonArea.widget, 16)

	// Add the areas to the main box
	mainBox.Append(dialog.contentArea)
	mainBox.Append(dialog.buttonArea)

	// Add the main box to the window
	dialog.SetChild(mainBox)

	// Set up default size
	dialog.SetDefaultSize(400, 200)

	return dialog
}

// AddButton adds a button to the dialog
func (d *Dialog) AddButton(text string, responseId ResponseType) *Button {
	// Create a button
	button := NewButton(text)

	// Add it to the button area
	d.buttonArea.Append(button)

	// Connect button to response using C helper
	C.connectButtonResponse(
		(*C.GtkButton)(unsafe.Pointer(button.widget)),
		C.int(responseId),
		C.gpointer(unsafe.Pointer(d.widget)),
	)

	return button
}

// GetContentArea gets the content area of the dialog
func (d *Dialog) GetContentArea() *Box {
	return d.contentArea
}

// ConnectResponse connects a response callback to the dialog
func (d *Dialog) ConnectResponse(callback DialogResponseCallback) {
	dialogCallbackMutex.Lock()
	defer dialogCallbackMutex.Unlock()

	dialogPtr := uintptr(unsafe.Pointer(d.widget))
	dialogCallbacks[dialogPtr] = callback

	DebugLog(DebugLevelInfo, DebugComponentDialog, "Connected response callback to dialog %v", dialogPtr)
}

// Destroy overrides Window's Destroy to clean up dialog resources
func (d *Dialog) Destroy() {
	DebugLog(DebugLevelInfo, DebugComponentDialog, "Destroying dialog %v", uintptr(unsafe.Pointer(d.widget)))

	dialogCallbackMutex.Lock()
	delete(dialogCallbacks, uintptr(unsafe.Pointer(d.widget)))
	dialogCallbackMutex.Unlock()

	d.Window.Destroy()
}

// MessageType defines the type of message dialog
type MessageType int

const (
	// MessageInfo for informational messages
	MessageInfo MessageType = iota
	// MessageWarning for warning messages
	MessageWarning
	// MessageQuestion for questions requiring user response
	MessageQuestion
	// MessageError for error messages
	MessageError
	// MessageOther for other messages
	MessageOther
)

// MessageDialog represents a GTK message dialog
type MessageDialog struct {
	Dialog
	messageType MessageType
}

// NewMessageDialog creates a new message dialog
func NewMessageDialog(parent *Window, flags DialogFlags, messageType MessageType, buttons ResponseType, message string) *MessageDialog {
	// Create a dialog
	dialog := NewDialog("", parent, flags)

	// Create a message dialog
	msgDialog := &MessageDialog{
		Dialog:      *dialog,
		messageType: messageType,
	}

	// Set CSS class based on message type
	switch messageType {
	case MessageInfo:
		msgDialog.AddCssClass("info-dialog")
	case MessageWarning:
		msgDialog.AddCssClass("warning-dialog")
	case MessageQuestion:
		msgDialog.AddCssClass("question-dialog")
	case MessageError:
		msgDialog.AddCssClass("error-dialog")
	}

	// Add message label
	msgLabel := NewLabel(message)
	msgLabel.AddCssClass("dialog-message")
	msgDialog.GetContentArea().Append(msgLabel)

	// Add buttons
	if buttons&ResponseOk != 0 {
		msgDialog.AddButton("OK", ResponseOk)
	}
	if buttons&ResponseClose != 0 {
		msgDialog.AddButton("Close", ResponseClose)
	}
	if buttons&ResponseCancel != 0 {
		msgDialog.AddButton("Cancel", ResponseCancel)
	}
	if buttons&ResponseYes != 0 {
		msgDialog.AddButton("Yes", ResponseYes)
	}
	if buttons&ResponseNo != 0 {
		msgDialog.AddButton("No", ResponseNo)
	}

	return msgDialog
}

// FileDialogAction defines the type of file chooser
type FileDialogAction int

const (
	// FileDialogActionOpen for selecting an existing file
	FileDialogActionOpen FileDialogAction = iota
	// FileDialogActionSave for saving a file
	FileDialogActionSave
	// FileDialogActionSelectFolder for selecting a folder
	FileDialogActionSelectFolder
)

// FileDialog represents a GTK file chooser dialog
type FileDialog struct {
	Dialog
	fileEntry  *Entry
	actionType FileDialogAction
}

// NewFileDialog creates a new file chooser dialog
func NewFileDialog(title string, parent *Window, action FileDialogAction) *FileDialog {
	// Create a dialog
	dialog := NewDialog(title, parent, DialogModal)

	// Create a file dialog
	fileDialog := &FileDialog{
		Dialog:     *dialog,
		actionType: action,
	}

	// Add content
	contentArea := fileDialog.GetContentArea()

	// Add label based on action
	var labelText string
	switch action {
	case FileDialogActionOpen:
		labelText = "Select a file to open:"
	case FileDialogActionSave:
		labelText = "Save file as:"
	case FileDialogActionSelectFolder:
		labelText = "Select folder:"
	}

	fileLabel := NewLabel(labelText)
	contentArea.Append(fileLabel)

	// Add entry for file path
	fileDialog.fileEntry = NewEntry()

	// Set placeholder text
	switch action {
	case FileDialogActionOpen:
		fileDialog.fileEntry.SetPlaceholderText("File path")
	case FileDialogActionSave:
		fileDialog.fileEntry.SetPlaceholderText("Enter filename")
	case FileDialogActionSelectFolder:
		fileDialog.fileEntry.SetPlaceholderText("Folder path")
	}

	contentArea.Append(fileDialog.fileEntry)

	// Add appropriate buttons
	switch action {
	case FileDialogActionOpen:
		fileDialog.AddButton("Cancel", ResponseCancel)
		fileDialog.AddButton("Open", ResponseAccept)
	case FileDialogActionSave:
		fileDialog.AddButton("Cancel", ResponseCancel)
		fileDialog.AddButton("Save", ResponseAccept)
	case FileDialogActionSelectFolder:
		fileDialog.AddButton("Cancel", ResponseCancel)
		fileDialog.AddButton("Select", ResponseAccept)
	}

	return fileDialog
}

// GetFilename gets the filename from the file dialog
func (d *FileDialog) GetFilename() string {
	return d.fileEntry.GetText()
}

// SetFilename sets the filename in the file dialog
func (d *FileDialog) SetFilename(filename string) {
	d.fileEntry.SetText(filename)
}



############################################################
# File: gtk4/entry.go
############################################################

// Package gtk4 provides entry widget functionality for GTK4
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Helper function to properly handle max length with correct types
// static void set_max_length(GtkEntryBuffer *buffer, unsigned int max_length) {
//     gtk_entry_buffer_set_max_length(buffer, (gsize)max_length);
// }
//
// // Helper function to get max length with correct type conversion
// static unsigned int get_max_length(GtkEntryBuffer *buffer) {
//     return (unsigned int)gtk_entry_buffer_get_max_length(buffer);
// }
import "C"

import (
	"runtime"
	"unsafe"
)

// EntryOption is a function that configures an entry
type EntryOption func(*Entry)

// Entry represents a GTK entry widget for text input
type Entry struct {
	BaseWidget
}

// NewEntry creates a new GTK entry widget
func NewEntry(options ...EntryOption) *Entry {
	entry := &Entry{
		BaseWidget: BaseWidget{
			widget: C.gtk_entry_new(),
		},
	}

	// Apply options
	for _, option := range options {
		option(entry)
	}

	SetupFinalization(entry, entry.Destroy)
	return entry
}

// WithEntryBuffer creates an entry with a specific buffer
func WithEntryBuffer(buffer *EntryBuffer) EntryOption {
	return func(e *Entry) {
		e.widget = C.gtk_entry_new_with_buffer(buffer.buffer)
	}
}

// WithPlaceholderText sets placeholder text
func WithPlaceholderText(text string) EntryOption {
	return func(e *Entry) {
		e.SetPlaceholderText(text)
	}
}

// WithEditable sets whether the entry is editable
func WithEditable(editable bool) EntryOption {
	return func(e *Entry) {
		e.SetEditable(editable)
	}
}

// SetText sets the text in the entry
func (e *Entry) SetText(text string) {
	WithCString(text, func(cText *C.char) {
		C.gtk_editable_set_text((*C.GtkEditable)(unsafe.Pointer(e.widget)), cText)
	})
}

// GetText gets the text from the entry
func (e *Entry) GetText() string {
	cText := C.gtk_editable_get_text((*C.GtkEditable)(unsafe.Pointer(e.widget)))
	if cText == nil {
		return ""
	}
	return C.GoString(cText)
}

// SetPlaceholderText sets the placeholder text shown when the entry is empty
func (e *Entry) SetPlaceholderText(text string) {
	WithCString(text, func(cText *C.char) {
		C.gtk_entry_set_placeholder_text((*C.GtkEntry)(unsafe.Pointer(e.widget)), cText)
	})
}

// GetPlaceholderText gets the placeholder text
func (e *Entry) GetPlaceholderText() string {
	cText := C.gtk_entry_get_placeholder_text((*C.GtkEntry)(unsafe.Pointer(e.widget)))
	if cText == nil {
		return ""
	}
	return C.GoString(cText)
}

// SetEditable sets whether the user can edit the text
func (e *Entry) SetEditable(editable bool) {
	var ceditable C.gboolean
	if editable {
		ceditable = C.TRUE
	} else {
		ceditable = C.FALSE
	}
	C.gtk_editable_set_editable((*C.GtkEditable)(unsafe.Pointer(e.widget)), ceditable)
}

// GetEditable gets whether the user can edit the text
func (e *Entry) GetEditable() bool {
	return C.gtk_editable_get_editable((*C.GtkEditable)(unsafe.Pointer(e.widget))) == C.TRUE
}

// SetVisibility sets whether the text is visible or hidden (e.g., for passwords)
func (e *Entry) SetVisibility(visible bool) {
	var cvisible C.gboolean
	if visible {
		cvisible = C.TRUE
	} else {
		cvisible = C.FALSE
	}
	C.gtk_entry_set_visibility((*C.GtkEntry)(unsafe.Pointer(e.widget)), cvisible)
}

// GetVisibility gets whether the text is visible
func (e *Entry) GetVisibility() bool {
	return C.gtk_entry_get_visibility((*C.GtkEntry)(unsafe.Pointer(e.widget))) == C.TRUE
}

// ConnectChanged connects a callback function to the entry's "changed" signal
func (e *Entry) ConnectChanged(callback func()) {
	Connect(e, SignalChanged, callback)
}

// ConnectActivate connects a callback function to the entry's "activate" signal
func (e *Entry) ConnectActivate(callback func()) {
	Connect(e, SignalActivate, callback)
}

// DisconnectChanged disconnects the changed signal handler
func (e *Entry) DisconnectChanged() {
	// Since we don't have a specific disconnect function for a single signal type,
	// we'll have to disconnect all signal handlers
	DisconnectAll(e)
}

// DisconnectActivate disconnects the activate signal handler
func (e *Entry) DisconnectActivate() {
	// Since we don't have a specific disconnect function for a single signal type,
	// we'll have to disconnect all signal handlers
	DisconnectAll(e)
}

// Destroy destroys the entry and cleans up resources
func (e *Entry) Destroy() {
	// Disconnect all signals
	DisconnectAll(e)
	
	// Call base destroy method
	e.BaseWidget.Destroy()
}

// EntryBuffer represents a GTK entry buffer
type EntryBuffer struct {
	buffer *C.GtkEntryBuffer
}

// NewEntryBuffer creates a new entry buffer with initial text
func NewEntryBuffer(initialText string) *EntryBuffer {
	var buffer *C.GtkEntryBuffer

	WithCString(initialText, func(cText *C.char) {
		buffer = C.gtk_entry_buffer_new(cText, C.int(len(initialText)))
	})

	entryBuffer := &EntryBuffer{
		buffer: buffer,
	}

	// Use a simple finalizer
	runtime.SetFinalizer(entryBuffer, func(b *EntryBuffer) {
		b.Free()
	})

	return entryBuffer
}

// SetText sets the text in the buffer
func (b *EntryBuffer) SetText(text string) {
	WithCString(text, func(cText *C.char) {
		C.gtk_entry_buffer_set_text(b.buffer, cText, C.int(len(text)))
	})
}

// GetText gets the text from the buffer
func (b *EntryBuffer) GetText() string {
	cText := C.gtk_entry_buffer_get_text(b.buffer)
	if cText == nil {
		return ""
	}
	return C.GoString(cText)
}

// GetLength gets the length of the text in the buffer
func (b *EntryBuffer) GetLength() int {
	return int(C.gtk_entry_buffer_get_length(b.buffer))
}

// Free frees the buffer
func (b *EntryBuffer) Free() {
	if b.buffer != nil {
		C.g_object_unref(C.gpointer(unsafe.Pointer(b.buffer)))
		b.buffer = nil
	}
}

// SetMaxLength sets the maximum length of the text in the buffer
func (b *EntryBuffer) SetMaxLength(length uint) {
	// Use our helper function to handle type conversion correctly
	C.set_max_length(b.buffer, C.uint(length))
}

// GetMaxLength gets the maximum length of the text in the buffer
func (b *EntryBuffer) GetMaxLength() uint {
	// Use our helper function to handle type conversion correctly
	return uint(C.get_max_length(b.buffer))
}

// InputPurpose defines the purpose of an entry
type InputPurpose int

const (
	// InputPurposeFreeForm for normal text entry
	InputPurposeFreeForm InputPurpose = C.GTK_INPUT_PURPOSE_FREE_FORM
	// InputPurposeAlpha for alphabetic entry
	InputPurposeAlpha InputPurpose = C.GTK_INPUT_PURPOSE_ALPHA
	// InputPurposeDigits for digit entry
	InputPurposeDigits InputPurpose = C.GTK_INPUT_PURPOSE_DIGITS
	// InputPurposeNumber for number entry
	InputPurposeNumber InputPurpose = C.GTK_INPUT_PURPOSE_NUMBER
	// InputPurposePhone for phone number entry
	InputPurposePhone InputPurpose = C.GTK_INPUT_PURPOSE_PHONE
	// InputPurposeURL for URL entry
	InputPurposeURL InputPurpose = C.GTK_INPUT_PURPOSE_URL
	// InputPurposeEmail for email entry
	InputPurposeEmail InputPurpose = C.GTK_INPUT_PURPOSE_EMAIL
	// InputPurposeName for name entry
	InputPurposeName InputPurpose = C.GTK_INPUT_PURPOSE_NAME
	// InputPurposePassword for password entry
	InputPurposePassword InputPurpose = C.GTK_INPUT_PURPOSE_PASSWORD
	// InputPurposePin for PIN entry
	InputPurposePin InputPurpose = C.GTK_INPUT_PURPOSE_PIN
)

// SetInputPurpose sets the purpose of the entry
func (e *Entry) SetInputPurpose(purpose InputPurpose) {
	C.gtk_entry_set_input_purpose((*C.GtkEntry)(unsafe.Pointer(e.widget)), C.GtkInputPurpose(purpose))
}

// GetInputPurpose gets the purpose of the entry
func (e *Entry) GetInputPurpose() InputPurpose {
	return InputPurpose(C.gtk_entry_get_input_purpose((*C.GtkEntry)(unsafe.Pointer(e.widget))))
}

// InputHints defines input hints for an entry
type InputHints int

const (
	// InputHintsNone for no hints
	InputHintsNone InputHints = C.GTK_INPUT_HINT_NONE
	// InputHintsSpellcheck to enable spellcheck
	InputHintsSpellcheck InputHints = C.GTK_INPUT_HINT_SPELLCHECK
	// InputHintsNoSpellcheck to disable spellcheck
	InputHintsNoSpellcheck InputHints = C.GTK_INPUT_HINT_NO_SPELLCHECK
	// InputHintsWordCompletion to enable word completion
	InputHintsWordCompletion InputHints = C.GTK_INPUT_HINT_WORD_COMPLETION
	// InputHintsLowercase to prefer lowercase
	InputHintsLowercase InputHints = C.GTK_INPUT_HINT_LOWERCASE
)

// SetInputHints sets the input hints for the entry
func (e *Entry) SetInputHints(hints InputHints) {
	C.gtk_entry_set_input_hints((*C.GtkEntry)(unsafe.Pointer(e.widget)), C.GtkInputHints(hints))
}

// GetInputHints gets the input hints for the entry
func (e *Entry) GetInputHints() InputHints {
	return InputHints(C.gtk_entry_get_input_hints((*C.GtkEntry)(unsafe.Pointer(e.widget))))
}

// SetAlignment sets the alignment for the entry text
func (e *Entry) SetAlignment(xalign float32) {
	C.gtk_entry_set_alignment((*C.GtkEntry)(unsafe.Pointer(e.widget)), C.gfloat(xalign))
}

// GetAlignment gets the alignment for the entry text
func (e *Entry) GetAlignment() float32 {
	return float32(C.gtk_entry_get_alignment((*C.GtkEntry)(unsafe.Pointer(e.widget))))
}

// SetProgressFraction sets the current fraction of the task that's been completed
func (e *Entry) SetProgressFraction(fraction float64) {
	C.gtk_entry_set_progress_fraction((*C.GtkEntry)(unsafe.Pointer(e.widget)), C.gdouble(fraction))
}

// GetProgressFraction gets the current fraction of the task that's been completed
func (e *Entry) GetProgressFraction() float64 {
	return float64(C.gtk_entry_get_progress_fraction((*C.GtkEntry)(unsafe.Pointer(e.widget))))
}

// SetProgressPulseStep sets the fraction of total entry width to move the progress bouncing block
func (e *Entry) SetProgressPulseStep(fraction float64) {
	C.gtk_entry_set_progress_pulse_step((*C.GtkEntry)(unsafe.Pointer(e.widget)), C.gdouble(fraction))
}

// GetProgressPulseStep gets the fraction of total entry width to move the progress bouncing block
func (e *Entry) GetProgressPulseStep() float64 {
	return float64(C.gtk_entry_get_progress_pulse_step((*C.GtkEntry)(unsafe.Pointer(e.widget))))
}

// ProgressPulse causes the entry's progress indicator to enter "activity mode"
func (e *Entry) ProgressPulse() {
	C.gtk_entry_progress_pulse((*C.GtkEntry)(unsafe.Pointer(e.widget)))
}

// SetEnableUndo sets whether the user can undo/redo entry edits
func (e *Entry) SetEnableUndo(enabled bool) {
	var cenabled C.gboolean
	if enabled {
		cenabled = C.TRUE
	} else {
		cenabled = C.FALSE
	}
	C.gtk_editable_set_enable_undo((*C.GtkEditable)(unsafe.Pointer(e.widget)), cenabled)
}

// GetEnableUndo gets whether the user can undo/redo entry edits
func (e *Entry) GetEnableUndo() bool {
	return C.gtk_editable_get_enable_undo((*C.GtkEditable)(unsafe.Pointer(e.widget))) == C.TRUE
}

############################################################
# File: gtk4/grid.go
############################################################

// Package gtk4 provides grid layout functionality for GTK4
// File: gtk4go/gtk4/grid.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// GridOption is a function that configures a grid
type GridOption func(*Grid)

// Grid represents a GTK grid container
type Grid struct {
	BaseWidget
}

// NewGrid creates a new GTK grid container
func NewGrid(options ...GridOption) *Grid {
	grid := &Grid{
		BaseWidget: BaseWidget{
			widget: C.gtk_grid_new(),
		},
	}

	// Apply options
	for _, option := range options {
		option(grid)
	}

	SetupFinalization(grid, grid.Destroy)
	return grid
}

// WithRowSpacing sets spacing between rows
func WithRowSpacing(spacing int) GridOption {
	return func(g *Grid) {
		C.gtk_grid_set_row_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.guint(spacing))
	}
}

// WithColumnSpacing sets spacing between columns
func WithColumnSpacing(spacing int) GridOption {
	return func(g *Grid) {
		C.gtk_grid_set_column_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.guint(spacing))
	}
}

// WithRowHomogeneous sets whether all rows have the same height
func WithRowHomogeneous(homogeneous bool) GridOption {
	return func(g *Grid) {
		var chomogeneous C.gboolean
		if homogeneous {
			chomogeneous = C.TRUE
		} else {
			chomogeneous = C.FALSE
		}
		C.gtk_grid_set_row_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget)), chomogeneous)
	}
}

// WithColumnHomogeneous sets whether all columns have the same width
func WithColumnHomogeneous(homogeneous bool) GridOption {
	return func(g *Grid) {
		var chomogeneous C.gboolean
		if homogeneous {
			chomogeneous = C.TRUE
		} else {
			chomogeneous = C.FALSE
		}
		C.gtk_grid_set_column_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget)), chomogeneous)
	}
}

// Attach attaches a widget to the grid at the given position
func (g *Grid) Attach(child Widget, column, row, width, height int) {
	C.gtk_grid_attach(
		(*C.GtkGrid)(unsafe.Pointer(g.widget)),
		child.GetWidget(),
		C.int(column),
		C.int(row),
		C.int(width),
		C.int(height),
	)
}

// AttachNextTo attaches a widget to the grid, next to another widget
func (g *Grid) AttachNextTo(child, sibling Widget, side GridPosition, width, height int) {
	C.gtk_grid_attach_next_to(
		(*C.GtkGrid)(unsafe.Pointer(g.widget)),
		child.GetWidget(),
		sibling.GetWidget(),
		C.GtkPositionType(side),
		C.int(width),
		C.int(height),
	)
}

// InsertRow inserts a row at the specified position
func (g *Grid) InsertRow(position int) {
	C.gtk_grid_insert_row((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.int(position))
}

// InsertColumn inserts a column at the specified position
func (g *Grid) InsertColumn(position int) {
	C.gtk_grid_insert_column((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.int(position))
}

// RemoveRow removes a row from the grid
func (g *Grid) RemoveRow(position int) {
	C.gtk_grid_remove_row((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.int(position))
}

// RemoveColumn removes a column from the grid
func (g *Grid) RemoveColumn(position int) {
	C.gtk_grid_remove_column((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.int(position))
}

// GetChildAt gets the child at the specified position
func (g *Grid) GetChildAt(column, row int) Widget {
	widget := C.gtk_grid_get_child_at(
		(*C.GtkGrid)(unsafe.Pointer(g.widget)),
		C.int(column),
		C.int(row),
	)

	// We can't directly return a Widget from the C pointer
	// Instead, we would need to wrap it in an appropriate Go struct
	// This is a simplified implementation that returns nil
	if widget == nil {
		return nil
	}

	// In a real implementation, we would determine the type of widget
	// and return an appropriate Go wrapper
	return nil
}

// SetRowSpacing sets the amount of space between rows
func (g *Grid) SetRowSpacing(spacing int) {
	C.gtk_grid_set_row_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.guint(spacing))
}

// GetRowSpacing gets the amount of space between rows
func (g *Grid) GetRowSpacing() int {
	return int(C.gtk_grid_get_row_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget))))
}

// SetColumnSpacing sets the amount of space between columns
func (g *Grid) SetColumnSpacing(spacing int) {
	C.gtk_grid_set_column_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget)), C.guint(spacing))
}

// GetColumnSpacing gets the amount of space between columns
func (g *Grid) GetColumnSpacing() int {
	return int(C.gtk_grid_get_column_spacing((*C.GtkGrid)(unsafe.Pointer(g.widget))))
}

// SetRowHomogeneous sets whether all rows should be the same height
func (g *Grid) SetRowHomogeneous(homogeneous bool) {
	var chomogeneous C.gboolean
	if homogeneous {
		chomogeneous = C.TRUE
	} else {
		chomogeneous = C.FALSE
	}
	C.gtk_grid_set_row_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget)), chomogeneous)
}

// GetRowHomogeneous gets whether all rows are the same height
func (g *Grid) GetRowHomogeneous() bool {
	return C.gtk_grid_get_row_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget))) == C.TRUE
}

// SetColumnHomogeneous sets whether all columns should be the same width
func (g *Grid) SetColumnHomogeneous(homogeneous bool) {
	var chomogeneous C.gboolean
	if homogeneous {
		chomogeneous = C.TRUE
	} else {
		chomogeneous = C.FALSE
	}
	C.gtk_grid_set_column_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget)), chomogeneous)
}

// GetColumnHomogeneous gets whether all columns are the same width
func (g *Grid) GetColumnHomogeneous() bool {
	return C.gtk_grid_get_column_homogeneous((*C.GtkGrid)(unsafe.Pointer(g.widget))) == C.TRUE
}

// GridPosition defines the position relative to another widget
type GridPosition int

const (
	// PositionLeft positions a widget to the left of another widget
	PositionLeft GridPosition = C.GTK_POS_LEFT
	// PositionRight positions a widget to the right of another widget
	PositionRight GridPosition = C.GTK_POS_RIGHT
	// PositionTop positions a widget above another widget
	PositionTop GridPosition = C.GTK_POS_TOP
	// PositionBottom positions a widget below another widget
	PositionBottom GridPosition = C.GTK_POS_BOTTOM
)


############################################################
# File: gtk4/label.go
############################################################

// Package gtk4 provides label functionality for GTK4
// File: gtk4go/gtk4/label.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// LabelOption is a function that configures a label
type LabelOption func(*Label)

// Label represents a GTK label
type Label struct {
	BaseWidget
}

// NewLabel creates a new GTK label with the given text
func NewLabel(text string, options ...LabelOption) *Label {
	var widget *C.GtkWidget

	WithCString(text, func(cText *C.char) {
		widget = C.gtk_label_new(cText)
	})

	label := &Label{
		BaseWidget: BaseWidget{
			widget: widget,
		},
	}

	// Apply options
	for _, option := range options {
		option(label)
	}

	SetupFinalization(label, label.Destroy)
	return label
}

// WithMarkup configures a label to use markup
func WithMarkup(markup string) LabelOption {
	return func(l *Label) {
		l.SetMarkup(markup)
	}
}

// WithSelectable makes the label selectable
func WithSelectable(selectable bool) LabelOption {
	return func(l *Label) {
		var cselectable C.gboolean
		if selectable {
			cselectable = C.TRUE
		} else {
			cselectable = C.FALSE
		}
		C.gtk_label_set_selectable((*C.GtkLabel)(unsafe.Pointer(l.widget)), cselectable)
	}
}

// SetText sets the label text
func (l *Label) SetText(text string) {
	WithCString(text, func(cText *C.char) {
		C.gtk_label_set_text((*C.GtkLabel)(unsafe.Pointer(l.widget)), cText)
	})
}

// SetMarkup sets the label markup
func (l *Label) SetMarkup(markup string) {
	WithCString(markup, func(cMarkup *C.char) {
		C.gtk_label_set_markup((*C.GtkLabel)(unsafe.Pointer(l.widget)), cMarkup)
	})
}

// GetText gets the label text
func (l *Label) GetText() string {
	cText := C.gtk_label_get_text((*C.GtkLabel)(unsafe.Pointer(l.widget)))
	return C.GoString(cText)
}


############################################################
# File: gtk4/listItem.go
############################################################

// Package gtk4 provides list item functionality for GTK4
// File: gtk4go/gtk4/listitem.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// static GtkWidget* listItemGetChild(GtkListItem *list_item) {
//     return gtk_list_item_get_child(list_item);
// }
//
// static void listItemSetChild(GtkListItem *list_item, GtkWidget *child) {
//     gtk_list_item_set_child(list_item, child);
// }
//
// static gpointer listItemGetItem(GtkListItem *list_item) {
//     return gtk_list_item_get_item(list_item);
// }
//
// static guint listItemGetPosition(GtkListItem *list_item) {
//     return gtk_list_item_get_position(list_item);
// }
//
// static gboolean listItemGetSelected(GtkListItem *list_item) {
//     return gtk_list_item_get_selected(list_item);
// }
import "C"

import (
	"unsafe"
)

// ListItem represents a GTK list item
type ListItem struct {
	listItem *C.GtkListItem
}

// GetChild returns the child widget of the list item
func (li *ListItem) GetChild() Widget {
	widget := C.listItemGetChild(li.listItem)
	if widget == nil {
		return nil
	}

	// Note: This would need to return a Go wrapper for the widget
	// For now, return a generic BaseWidget as a placeholder
	return &BaseWidget{widget: widget}
}

// SetChild sets the child widget for the list item
func (li *ListItem) SetChild(child Widget) {
	C.listItemSetChild(li.listItem, child.GetWidget())
}

// GetItem returns the model item associated with the list item
func (li *ListItem) GetItem() interface{} {
	item := C.listItemGetItem(li.listItem)
	if item == nil {
		return nil
	}

	// The actual implementation would need to convert the C item
	// to the appropriate Go type based on the model being used
	// For now, just return the raw pointer
	return uintptr(unsafe.Pointer(item))
}

// GetPosition returns the position of the list item in the model
func (li *ListItem) GetPosition() int {
	return int(C.listItemGetPosition(li.listItem))
}

// GetSelected returns whether the list item is selected
func (li *ListItem) GetSelected() bool {
	return bool(C.listItemGetSelected(li.listItem) != 0)
}

############################################################
# File: gtk4/listItemFactory.go
############################################################

// Package gtk4 provides list item factory functionality for GTK4
// File: gtk4go/gtk4/listitemfactory.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Signal list item factory callbacks
// extern void setupListItemCallback(GtkSignalListItemFactory *factory, GtkListItem *list_item, gpointer user_data);
// extern void bindListItemCallback(GtkSignalListItemFactory *factory, GtkListItem *list_item, gpointer user_data);
// extern void unbindListItemCallback(GtkSignalListItemFactory *factory, GtkListItem *list_item, gpointer user_data);
// extern void teardownListItemCallback(GtkSignalListItemFactory *factory, GtkListItem *list_item, gpointer user_data);
//
// // Connect signals for list item factory
// static GtkSignalListItemFactory* createSignalListItemFactory() {
//     return (GtkSignalListItemFactory*)gtk_signal_list_item_factory_new();
// }
//
// static gulong connectSetupListItem(GtkSignalListItemFactory *factory, gpointer user_data) {
//     return g_signal_connect(factory, "setup", G_CALLBACK(setupListItemCallback), user_data);
// }
//
// static gulong connectBindListItem(GtkSignalListItemFactory *factory, gpointer user_data) {
//     return g_signal_connect(factory, "bind", G_CALLBACK(bindListItemCallback), user_data);
// }
//
// static gulong connectUnbindListItem(GtkSignalListItemFactory *factory, gpointer user_data) {
//     return g_signal_connect(factory, "unbind", G_CALLBACK(unbindListItemCallback), user_data);
// }
//
// static gulong connectTeardownListItem(GtkSignalListItemFactory *factory, gpointer user_data) {
//     return g_signal_connect(factory, "teardown", G_CALLBACK(teardownListItemCallback), user_data);
// }
import "C"

import (
	"runtime"
	"sync"
	"unsafe"
)

// ListItemCallback represents a callback for list item operations
type ListItemCallback func(listItem *ListItem)

// ListItemCallbackType defines the types of callbacks for list item factory
type ListItemCallbackType int

const (
	// ListItemCallbackSetup is called when a new list item is created
	ListItemCallbackSetup ListItemCallbackType = iota
	// ListItemCallbackBind is called when a list item is bound to a model item
	ListItemCallbackBind
	// ListItemCallbackUnbind is called when a list item is unbound from a model item
	ListItemCallbackUnbind
	// ListItemCallbackTeardown is called when a list item is destroyed
	ListItemCallbackTeardown
)

var (
	// Map of factory pointers to maps of callback types to callbacks
	factoryCallbacks     = make(map[uintptr]map[ListItemCallbackType]ListItemCallback)
	factoryCallbackMutex sync.RWMutex
)

//export setupListItemCallback
func setupListItemCallback(factory *C.GtkSignalListItemFactory, listItem *C.GtkListItem, userData C.gpointer) {
	factoryCallbackMutex.RLock()
	defer factoryCallbackMutex.RUnlock()

	// Convert factory pointer to uintptr for lookup
	factoryPtr := uintptr(unsafe.Pointer(factory))

	// Find and call the callback
	if callbacks, ok := factoryCallbacks[factoryPtr]; ok {
		if callback, ok := callbacks[ListItemCallbackSetup]; ok {
			callback(&ListItem{listItem: listItem})
		}
	}
}

//export bindListItemCallback
func bindListItemCallback(factory *C.GtkSignalListItemFactory, listItem *C.GtkListItem, userData C.gpointer) {
	factoryCallbackMutex.RLock()
	defer factoryCallbackMutex.RUnlock()

	// Convert factory pointer to uintptr for lookup
	factoryPtr := uintptr(unsafe.Pointer(factory))

	// Find and call the callback
	if callbacks, ok := factoryCallbacks[factoryPtr]; ok {
		if callback, ok := callbacks[ListItemCallbackBind]; ok {
			callback(&ListItem{listItem: listItem})
		}
	}
}

//export unbindListItemCallback
func unbindListItemCallback(factory *C.GtkSignalListItemFactory, listItem *C.GtkListItem, userData C.gpointer) {
	factoryCallbackMutex.RLock()
	defer factoryCallbackMutex.RUnlock()

	// Convert factory pointer to uintptr for lookup
	factoryPtr := uintptr(unsafe.Pointer(factory))

	// Find and call the callback
	if callbacks, ok := factoryCallbacks[factoryPtr]; ok {
		if callback, ok := callbacks[ListItemCallbackUnbind]; ok {
			callback(&ListItem{listItem: listItem})
		}
	}
}

//export teardownListItemCallback
func teardownListItemCallback(factory *C.GtkSignalListItemFactory, listItem *C.GtkListItem, userData C.gpointer) {
	factoryCallbackMutex.RLock()
	defer factoryCallbackMutex.RUnlock()

	// Convert factory pointer to uintptr for lookup
	factoryPtr := uintptr(unsafe.Pointer(factory))

	// Find and call the callback
	if callbacks, ok := factoryCallbacks[factoryPtr]; ok {
		if callback, ok := callbacks[ListItemCallbackTeardown]; ok {
			callback(&ListItem{listItem: listItem})
		}
	}
}

// ListItemFactory is an interface for factories that create list items
type ListItemFactory interface {
	// GetListItemFactory returns the underlying GtkListItemFactory pointer
	GetListItemFactory() *C.GtkListItemFactory

	// Destroy frees resources associated with the factory
	Destroy()
}

// SignalListItemFactory is a factory that creates list items using signals
type SignalListItemFactory struct {
	factory *C.GtkSignalListItemFactory
}

// NewSignalListItemFactory creates a new signal list item factory
func NewSignalListItemFactory() *SignalListItemFactory {
	factory := &SignalListItemFactory{
		factory: C.createSignalListItemFactory(),
	}

	// Initialize the callback map for this factory
	factoryCallbackMutex.Lock()
	factoryCallbacks[uintptr(unsafe.Pointer(factory.factory))] = make(map[ListItemCallbackType]ListItemCallback)
	factoryCallbackMutex.Unlock()

	runtime.SetFinalizer(factory, (*SignalListItemFactory).Destroy)
	return factory
}

// GetListItemFactory returns the underlying GtkListItemFactory pointer
func (f *SignalListItemFactory) GetListItemFactory() *C.GtkListItemFactory {
	return (*C.GtkListItemFactory)(unsafe.Pointer(f.factory))
}

// ConnectSetup connects a callback for the setup signal
func (f *SignalListItemFactory) ConnectSetup(callback ListItemCallback) {
	if callback == nil {
		return
	}

	factoryCallbackMutex.Lock()
	defer factoryCallbackMutex.Unlock()

	// Store the callback in the map
	factoryPtr := uintptr(unsafe.Pointer(f.factory))
	factoryCallbacks[factoryPtr][ListItemCallbackSetup] = callback

	// Connect the signal
	C.connectSetupListItem(f.factory, C.gpointer(unsafe.Pointer(f.factory)))
}

// ConnectBind connects a callback for the bind signal
func (f *SignalListItemFactory) ConnectBind(callback ListItemCallback) {
	if callback == nil {
		return
	}

	factoryCallbackMutex.Lock()
	defer factoryCallbackMutex.Unlock()

	// Store the callback in the map
	factoryPtr := uintptr(unsafe.Pointer(f.factory))
	factoryCallbacks[factoryPtr][ListItemCallbackBind] = callback

	// Connect the signal
	C.connectBindListItem(f.factory, C.gpointer(unsafe.Pointer(f.factory)))
}

// ConnectUnbind connects a callback for the unbind signal
func (f *SignalListItemFactory) ConnectUnbind(callback ListItemCallback) {
	if callback == nil {
		return
	}

	factoryCallbackMutex.Lock()
	defer factoryCallbackMutex.Unlock()

	// Store the callback in the map
	factoryPtr := uintptr(unsafe.Pointer(f.factory))
	factoryCallbacks[factoryPtr][ListItemCallbackUnbind] = callback

	// Connect the signal
	C.connectUnbindListItem(f.factory, C.gpointer(unsafe.Pointer(f.factory)))
}

// ConnectTeardown connects a callback for the teardown signal
func (f *SignalListItemFactory) ConnectTeardown(callback ListItemCallback) {
	if callback == nil {
		return
	}

	factoryCallbackMutex.Lock()
	defer factoryCallbackMutex.Unlock()

	// Store the callback in the map
	factoryPtr := uintptr(unsafe.Pointer(f.factory))
	factoryCallbacks[factoryPtr][ListItemCallbackTeardown] = callback

	// Connect the signal
	C.connectTeardownListItem(f.factory, C.gpointer(unsafe.Pointer(f.factory)))
}

// Destroy frees resources associated with the factory
func (f *SignalListItemFactory) Destroy() {
	if f.factory != nil {
		factoryCallbackMutex.Lock()
		delete(factoryCallbacks, uintptr(unsafe.Pointer(f.factory)))
		factoryCallbackMutex.Unlock()

		C.g_object_unref(C.gpointer(unsafe.Pointer(f.factory)))
		f.factory = nil
	}
}

############################################################
# File: gtk4/listModel.go
############################################################

// Package gtk4 provides list model functionality for GTK4
// File: gtk4go/gtk4/listmodel.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // ListModel callbacks
// extern void listModelItemsChangedCallback(GListModel *model, guint position, guint removed, guint added, gpointer user_data);
//
// // Connect signal for items-changed
// static gulong connectListModelItemsChanged(GListModel *model, gpointer user_data) {
//     return g_signal_connect(model, "items-changed", G_CALLBACK(listModelItemsChangedCallback), user_data);
// }
//
// // StringList operations
// static GtkStringList* createStringList() {
//     return gtk_string_list_new(NULL);
// }
//
// static void stringListAppend(GtkStringList *list, const char *string) {
//     gtk_string_list_append(list, string);
// }
//
// static void stringListRemove(GtkStringList *list, guint position) {
//     gtk_string_list_remove(list, position);
// }
//
// static guint stringListGetNItems(GtkStringList *list) {
//     return g_list_model_get_n_items(G_LIST_MODEL(list));
// }
//
// static const char* stringListGetString(GtkStringList *list, guint position) {
//     const char* result = NULL;
//     GtkStringObject *obj = GTK_STRING_OBJECT(g_list_model_get_item(G_LIST_MODEL(list), position));
//     if (obj != NULL) {
//         result = gtk_string_object_get_string(obj);
//         g_object_unref(obj);
//     }
//     return result;
// }
//
// // ListStore operations
// static GListStore* createListStore(GType item_type) {
//     return g_list_store_new(item_type);
// }
//
// static void listStoreAppend(GListStore *store, gpointer item) {
//     g_list_store_append(store, item);
// }
//
// static void listStoreRemove(GListStore *store, guint position) {
//     g_list_store_remove(store, position);
// }
//
// static gpointer listModelGetItem(GListModel *model, guint position) {
//     return g_list_model_get_item(model, position);
// }
//
// static guint listModelGetNItems(GListModel *model) {
//     return g_list_model_get_n_items(model);
// }
import "C"

import (
	"runtime"
	"sync"
	"unsafe"
)

// ListModelItemsChangedCallback represents a callback for list model changes
type ListModelItemsChangedCallback func(position, removed, added int)

var (
	listModelCallbacks     = make(map[uintptr]ListModelItemsChangedCallback)
	listModelCallbackMutex sync.RWMutex
)

//export listModelItemsChangedCallback
func listModelItemsChangedCallback(model *C.GListModel, position, removed, added C.guint, userData C.gpointer) {
	listModelCallbackMutex.RLock()
	defer listModelCallbackMutex.RUnlock()

	// Convert model pointer to uintptr for lookup
	modelPtr := uintptr(unsafe.Pointer(model))

	// Find and call the callback
	if callback, ok := listModelCallbacks[modelPtr]; ok {
		callback(int(position), int(removed), int(added))
	}
}

// ListModel is an interface for GTK list models
type ListModel interface {
	// GetListModel returns the underlying GListModel pointer
	GetListModel() *C.GListModel

	// GetNItems returns the number of items in the model
	GetNItems() int

	// GetItem returns the item at the given position
	GetItem(position int) interface{}

	// ConnectItemsChanged connects a callback for list model changes
	ConnectItemsChanged(callback ListModelItemsChangedCallback)

	// Destroy frees resources associated with the list model
	Destroy()
}

// BaseListModel provides common functionality for list models
type BaseListModel struct {
	model *C.GListModel
}

// GetListModel returns the underlying GListModel pointer
func (m *BaseListModel) GetListModel() *C.GListModel {
	return m.model
}

// GetNItems returns the number of items in the model
func (m *BaseListModel) GetNItems() int {
	return int(C.listModelGetNItems(m.model))
}

// GetItem returns the item at the given position as a generic interface{}
// Concrete implementations should override this method to return appropriate types
func (m *BaseListModel) GetItem(position int) interface{} {
	if position < 0 || position >= m.GetNItems() {
		return nil
	}
	
	// This is a generic implementation that returns the raw pointer
	// Concrete implementations should override this to return appropriate types
	item := C.listModelGetItem(m.model, C.guint(position))
	if item == nil {
		return nil
	}
	
	defer C.g_object_unref(C.gpointer(item))
	return uintptr(unsafe.Pointer(item))
}

// ConnectItemsChanged connects a callback for list model changes
func (m *BaseListModel) ConnectItemsChanged(callback ListModelItemsChangedCallback) {
	if callback == nil {
		return
	}

	listModelCallbackMutex.Lock()
	defer listModelCallbackMutex.Unlock()

	// Store the callback in the map
	modelPtr := uintptr(unsafe.Pointer(m.model))
	listModelCallbacks[modelPtr] = callback

	// Connect the signal
	C.connectListModelItemsChanged(m.model, C.gpointer(unsafe.Pointer(m.model)))
}

// Destroy frees resources associated with the list model
func (m *BaseListModel) Destroy() {
	if m.model != nil {
		listModelCallbackMutex.Lock()
		delete(listModelCallbacks, uintptr(unsafe.Pointer(m.model)))
		listModelCallbackMutex.Unlock()

		C.g_object_unref(C.gpointer(unsafe.Pointer(m.model)))
		m.model = nil
	}
}

// StringList is a list model for strings
type StringList struct {
	BaseListModel
	stringList *C.GtkStringList
}

// NewStringList creates a new string list
func NewStringList() *StringList {
	stringList := C.createStringList()
	list := &StringList{
		BaseListModel: BaseListModel{
			model: (*C.GListModel)(unsafe.Pointer(stringList)),
		},
		stringList: stringList,
	}

	runtime.SetFinalizer(list, (*StringList).Destroy)
	return list
}

// Append adds a string to the list
func (l *StringList) Append(str string) {
	cStr := C.CString(str)
	defer C.free(unsafe.Pointer(cStr))
	C.stringListAppend(l.stringList, cStr)
}

// Remove removes a string from the list at the given position
func (l *StringList) Remove(position int) {
	if position >= 0 && position < l.GetNItems() {
		C.stringListRemove(l.stringList, C.guint(position))
	}
}

// GetString returns the string at the given position
func (l *StringList) GetString(position int) string {
	if position < 0 || position >= l.GetNItems() {
		return ""
	}

	cStr := C.stringListGetString(l.stringList, C.guint(position))
	if cStr == nil {
		return ""
	}
	return C.GoString(cStr)
}

// GetItem returns the item at the given position as an interface{}
// For StringList, this returns the string at the given position
func (l *StringList) GetItem(position int) interface{} {
	return l.GetString(position)
}

// Destroy frees resources associated with the string list
func (l *StringList) Destroy() {
	l.BaseListModel.Destroy()
	l.stringList = nil
}

// ListStore is a generic list store
type ListStore struct {
	BaseListModel
	listStore *C.GListStore
	itemType  C.GType
	items     []interface{} // Keep Go references to items
}

// NewListStore creates a new list store with the given item type
func NewListStore(itemType C.GType) *ListStore {
	listStore := C.createListStore(itemType)
	store := &ListStore{
		BaseListModel: BaseListModel{
			model: (*C.GListModel)(unsafe.Pointer(listStore)),
		},
		listStore: listStore,
		itemType:  itemType,
		items:     make([]interface{}, 0),
	}

	runtime.SetFinalizer(store, (*ListStore).Destroy)
	return store
}

// Append adds an item to the list store
// Note: The implementation of this method depends on the type of items stored
// and would need customization for practical use
func (s *ListStore) Append(item interface{}) {
	// This is a simplified implementation that would need to be adapted
	// based on the actual item types being stored
	var cItem C.gpointer
	// Convert item to appropriate C pointer based on type
	// (Implementation would depend on the actual item types)

	C.listStoreAppend(s.listStore, cItem)
	s.items = append(s.items, item) // Store Go reference
}

// Remove removes an item from the list store at the given position
func (s *ListStore) Remove(position int) {
	if position >= 0 && position < len(s.items) {
		C.listStoreRemove(s.listStore, C.guint(position))
		// Remove the Go reference
		s.items = append(s.items[:position], s.items[position+1:]...)
	}
}

// GetItem returns the item at the given position
func (s *ListStore) GetItem(position int) interface{} {
	if position < 0 || position >= len(s.items) {
		return nil
	}
	return s.items[position]
}

// Destroy frees resources associated with the list store
func (s *ListStore) Destroy() {
	s.BaseListModel.Destroy()
	s.listStore = nil
	s.items = nil
}

############################################################
# File: gtk4/listView.go
############################################################

// Package gtk4 provides list view functionality for GTK4
// File: gtk4go/gtk4/listview.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // ListView operations
// static GtkWidget* createListView(GtkSelectionModel *model, GtkListItemFactory *factory) {
//     return gtk_list_view_new(model, factory);
// }
//
// static void listViewSetModel(GtkListView *list_view, GtkSelectionModel *model) {
//     gtk_list_view_set_model(list_view, model);
// }
//
// static GtkSelectionModel* listViewGetModel(GtkListView *list_view) {
//     return gtk_list_view_get_model(list_view);
// }
//
// static void listViewSetFactory(GtkListView *list_view, GtkListItemFactory *factory) {
//     gtk_list_view_set_factory(list_view, factory);
// }
//
// static GtkListItemFactory* listViewGetFactory(GtkListView *list_view) {
//     return gtk_list_view_get_factory(list_view);
// }
//
// static void listViewSetShowSeparators(GtkListView *list_view, gboolean show_separators) {
//     gtk_list_view_set_show_separators(list_view, show_separators);
// }
//
// static gboolean listViewGetShowSeparators(GtkListView *list_view) {
//     return gtk_list_view_get_show_separators(list_view);
// }
//
// static void listViewSetSingleClickActivate(GtkListView *list_view, gboolean single_click_activate) {
//     gtk_list_view_set_single_click_activate(list_view, single_click_activate);
// }
//
// static gboolean listViewGetSingleClickActivate(GtkListView *list_view) {
//     return gtk_list_view_get_single_click_activate(list_view);
// }
//
// static void listViewSetEnableRubberband(GtkListView *list_view, gboolean enable_rubberband) {
//     gtk_list_view_set_enable_rubberband(list_view, enable_rubberband);
// }
//
// static gboolean listViewGetEnableRubberband(GtkListView *list_view) {
//     return gtk_list_view_get_enable_rubberband(list_view);
// }
//
// // New in GTK 4.12: Scroll to API
// static void listViewScrollTo(GtkListView *list_view, guint position, GtkListScrollFlags flags) {
//     #if GTK_CHECK_VERSION(4, 12, 0)
//     #if GTK_CHECK_VERSION(4, 14, 0)
//         // In GTK 4.14+ the function requires a scroll_info parameter
//         GtkScrollInfo *scroll_info = NULL; // Default to NULL for automatic scrolling
//         gtk_list_view_scroll_to(list_view, position, flags, scroll_info);
//     #else
//         // In GTK 4.12-4.13, the function only takes position and flags
//         gtk_list_view_scroll_to(list_view, position, flags);
//     #endif
//     #endif
// }
//
// // New in GTK 4.12: Tab behavior API
// static void listViewSetTabBehavior(GtkListView *list_view, GtkListTabBehavior behavior) {
//     #if GTK_CHECK_VERSION(4, 12, 0)
//     gtk_list_view_set_tab_behavior(list_view, behavior);
//     #endif
// }
//
// static GtkListTabBehavior listViewGetTabBehavior(GtkListView *list_view) {
//     #if GTK_CHECK_VERSION(4, 12, 0)
//     return gtk_list_view_get_tab_behavior(list_view);
//     #else
//     return 0;
//     #endif
// }
//
// // New in GTK 4.12: Header factory API
// static void listViewSetHeaderFactory(GtkListView *list_view, GtkListItemFactory *factory) {
//     #if GTK_CHECK_VERSION(4, 12, 0)
//     gtk_list_view_set_header_factory(list_view, factory);
//     #endif
// }
//
// static GtkListItemFactory* listViewGetHeaderFactory(GtkListView *list_view) {
//     #if GTK_CHECK_VERSION(4, 12, 0)
//     return gtk_list_view_get_header_factory(list_view);
//     #else
//     return NULL;
//     #endif
// }
import "C"

import (
	"unsafe"
)

// ListScrollFlags represents the flags for scrolling to an item in the list
type ListScrollFlags int

const (
	// ListScrollNone indicates no special behavior
	ListScrollNone ListScrollFlags = 0
	// ListScrollFocus means focus the item when scrolling
	ListScrollFocus ListScrollFlags = 1 << 0
	// ListScrollSelect means select the item when scrolling
	ListScrollSelect ListScrollFlags = 1 << 1
)

// ListTabBehavior represents the behavior for tab navigation
type ListTabBehavior int

const (
	// ListTabAll allows tab to focus all items
	ListTabAll ListTabBehavior = 0
	// ListTabItem allows tab to focus only items
	ListTabItem ListTabBehavior = 1
	// ListTabRow allows tab to focus entire rows
	ListTabRow ListTabBehavior = 2
)

// ListViewActivateCallback represents a callback for list view item activation
type ListViewActivateCallback func(position int)

// ListViewOption is a function that configures a list view
type ListViewOption func(*ListView)

// ListView represents a GTK list view widget
type ListView struct {
	BaseWidget
	selectionModel SelectionModel
	factory        ListItemFactory
	headerFactory  ListItemFactory
}

// NewListView creates a new GTK list view
func NewListView(selectionModel SelectionModel, factory ListItemFactory, options ...ListViewOption) *ListView {
	var widget *C.GtkWidget

	// Create list view with selection model and factory if provided
	if selectionModel != nil && factory != nil {
		widget = C.createListView(selectionModel.GetSelectionModel(), factory.GetListItemFactory())
	} else {
		widget = C.createListView(nil, nil)
	}

	listView := &ListView{
		BaseWidget: BaseWidget{
			widget: widget,
		},
		selectionModel: selectionModel,
		factory:        factory,
	}

	// Apply options
	for _, option := range options {
		option(listView)
	}

	SetupFinalization(listView, listView.Destroy)
	return listView
}

// WithShowSeparators sets whether to show separators between items
func WithShowSeparators(showSeparators bool) ListViewOption {
	return func(lv *ListView) {
		var cshowSeparators C.gboolean
		if showSeparators {
			cshowSeparators = C.TRUE
		} else {
			cshowSeparators = C.FALSE
		}
		C.listViewSetShowSeparators((*C.GtkListView)(unsafe.Pointer(lv.widget)), cshowSeparators)
	}
}

// WithSingleClickActivate sets whether items are activated on single click
func WithSingleClickActivate(singleClickActivate bool) ListViewOption {
	return func(lv *ListView) {
		var csingleClickActivate C.gboolean
		if singleClickActivate {
			csingleClickActivate = C.TRUE
		} else {
			csingleClickActivate = C.FALSE
		}
		C.listViewSetSingleClickActivate((*C.GtkListView)(unsafe.Pointer(lv.widget)), csingleClickActivate)
	}
}

// WithEnableRubberband sets whether to enable rubberband selection
func WithEnableRubberband(enableRubberband bool) ListViewOption {
	return func(lv *ListView) {
		var cenableRubberband C.gboolean
		if enableRubberband {
			cenableRubberband = C.TRUE
		} else {
			cenableRubberband = C.FALSE
		}
		C.listViewSetEnableRubberband((*C.GtkListView)(unsafe.Pointer(lv.widget)), cenableRubberband)
	}
}

// WithTabBehavior sets the tab behavior for the list view (GTK 4.12+)
func WithTabBehavior(behavior ListTabBehavior) ListViewOption {
	return func(lv *ListView) {
		C.listViewSetTabBehavior((*C.GtkListView)(unsafe.Pointer(lv.widget)), C.GtkListTabBehavior(behavior))
	}
}

// WithHeaderFactory sets the header factory for the list view (GTK 4.12+)
func WithHeaderFactory(factory ListItemFactory) ListViewOption {
	return func(lv *ListView) {
		if factory != nil {
			C.listViewSetHeaderFactory((*C.GtkListView)(unsafe.Pointer(lv.widget)), factory.GetListItemFactory())
			lv.headerFactory = factory
		}
	}
}

// SetModel sets the selection model for the list view
func (lv *ListView) SetModel(model SelectionModel) {
	if model != nil {
		C.listViewSetModel((*C.GtkListView)(unsafe.Pointer(lv.widget)), model.GetSelectionModel())
		lv.selectionModel = model
	} else {
		C.listViewSetModel((*C.GtkListView)(unsafe.Pointer(lv.widget)), nil)
		lv.selectionModel = nil
	}
}

// GetModel returns the selection model for the list view
func (lv *ListView) GetModel() SelectionModel {
	return lv.selectionModel
}

// SetFactory sets the list item factory for the list view
func (lv *ListView) SetFactory(factory ListItemFactory) {
	if factory != nil {
		C.listViewSetFactory((*C.GtkListView)(unsafe.Pointer(lv.widget)), factory.GetListItemFactory())
		lv.factory = factory
	} else {
		C.listViewSetFactory((*C.GtkListView)(unsafe.Pointer(lv.widget)), nil)
		lv.factory = nil
	}
}

// GetFactory returns the list item factory for the list view
func (lv *ListView) GetFactory() ListItemFactory {
	return lv.factory
}

// SetHeaderFactory sets the header factory for the list view (GTK 4.12+)
func (lv *ListView) SetHeaderFactory(factory ListItemFactory) {
	if factory != nil {
		C.listViewSetHeaderFactory((*C.GtkListView)(unsafe.Pointer(lv.widget)), factory.GetListItemFactory())
		lv.headerFactory = factory
	} else {
		C.listViewSetHeaderFactory((*C.GtkListView)(unsafe.Pointer(lv.widget)), nil)
		lv.headerFactory = nil
	}
}

// GetHeaderFactory returns the header factory for the list view (GTK 4.12+)
func (lv *ListView) GetHeaderFactory() ListItemFactory {
	return lv.headerFactory
}

// SetShowSeparators sets whether to show separators between items
func (lv *ListView) SetShowSeparators(showSeparators bool) {
	var cshowSeparators C.gboolean
	if showSeparators {
		cshowSeparators = C.TRUE
	} else {
		cshowSeparators = C.FALSE
	}
	C.listViewSetShowSeparators((*C.GtkListView)(unsafe.Pointer(lv.widget)), cshowSeparators)
}

// GetShowSeparators returns whether separators are shown between items
func (lv *ListView) GetShowSeparators() bool {
	return C.listViewGetShowSeparators((*C.GtkListView)(unsafe.Pointer(lv.widget))) != 0
}

// SetSingleClickActivate sets whether items are activated on single click
func (lv *ListView) SetSingleClickActivate(singleClickActivate bool) {
	var csingleClickActivate C.gboolean
	if singleClickActivate {
		csingleClickActivate = C.TRUE
	} else {
		csingleClickActivate = C.FALSE
	}
	C.listViewSetSingleClickActivate((*C.GtkListView)(unsafe.Pointer(lv.widget)), csingleClickActivate)
}

// GetSingleClickActivate returns whether items are activated on single click
func (lv *ListView) GetSingleClickActivate() bool {
	return C.listViewGetSingleClickActivate((*C.GtkListView)(unsafe.Pointer(lv.widget))) != 0
}

// SetEnableRubberband sets whether to enable rubberband selection
func (lv *ListView) SetEnableRubberband(enableRubberband bool) {
	var cenableRubberband C.gboolean
	if enableRubberband {
		cenableRubberband = C.TRUE
	} else {
		cenableRubberband = C.FALSE
	}
	C.listViewSetEnableRubberband((*C.GtkListView)(unsafe.Pointer(lv.widget)), cenableRubberband)
}

// GetEnableRubberband returns whether rubberband selection is enabled
func (lv *ListView) GetEnableRubberband() bool {
	return C.listViewGetEnableRubberband((*C.GtkListView)(unsafe.Pointer(lv.widget))) != 0
}

// SetTabBehavior sets the tab behavior for the list view (GTK 4.12+)
func (lv *ListView) SetTabBehavior(behavior ListTabBehavior) {
	C.listViewSetTabBehavior((*C.GtkListView)(unsafe.Pointer(lv.widget)), C.GtkListTabBehavior(behavior))
}

// GetTabBehavior returns the tab behavior for the list view (GTK 4.12+)
func (lv *ListView) GetTabBehavior() ListTabBehavior {
	return ListTabBehavior(C.listViewGetTabBehavior((*C.GtkListView)(unsafe.Pointer(lv.widget))))
}

// ScrollTo scrolls to the item at the given position (GTK 4.12+)
func (lv *ListView) ScrollTo(position int, flags ListScrollFlags) {
	C.listViewScrollTo((*C.GtkListView)(unsafe.Pointer(lv.widget)), C.guint(position), C.GtkListScrollFlags(flags))
}

// ConnectActivate connects a callback for item activation
func (lv *ListView) ConnectActivate(callback ListViewActivateCallback) {
	if callback == nil {
		return
	}

	// To avoid type issues, convert the ListViewActivateCallback to a regular func(int)
	// since that's what the callback handler expects
	rawCallback := func(position int) {
		callback(position)
	}

	// Connect using the raw callback
	Connect(lv, SignalListActivate, rawCallback)

	DebugLog(DebugLevelInfo, DebugComponentListView, 
		"Connected activate callback to ListView %p", unsafe.Pointer(lv.widget))
}

// Destroy overrides BaseWidget's Destroy to clean up list view resources
func (lv *ListView) Destroy() {
	// Clean up callbacks using the unified system
	DisconnectAll(lv)
	
	lv.BaseWidget.Destroy()
}

############################################################
# File: gtk4/menu.go
############################################################

// Package gtk4 provides modern menu functionality for GTK4
// File: gtk4go/gtk4/menu.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Helper functions for GMenu operations
// static GMenuItem* create_menu_item(const char* label, const char* action) {
//     GMenuItem* item = g_menu_item_new(label, action);
//     return item;
// }
//
// static GMenu* create_menu() {
//     return g_menu_new();
// }
//
// static void append_item_to_menu(GMenu* menu, GMenuItem* item) {
//     g_menu_append_item(menu, item);
// }
//
// static void append_submenu_to_menu(GMenu* menu, const char* label, GMenu* submenu) {
//     g_menu_append_submenu(menu, label, G_MENU_MODEL(submenu));
// }
//
// // PopoverMenu helper functions
// static GtkWidget* create_popover_menu_from_model(GMenuModel* model) {
//     return gtk_popover_menu_new_from_model(model);
// }
//
// static void set_popover_menu_model(GtkPopoverMenu* popover, GMenuModel* model) {
//     gtk_popover_menu_set_menu_model(popover, model);
// }
//
// // Additional helper for set parent
// static void set_popover_parent(GtkPopover* popover, GtkWidget* parent) {
//     gtk_widget_set_parent(GTK_WIDGET(popover), parent);
// }
import "C"

import (
    "unsafe"
)

// Signal types for menu-specific signals not in callbacks.go
const (
    // For menu components
    SignalDeactivate SignalType = "deactivate"
)

// MenuItem represents a menu item
type MenuItem struct {
    item *C.GMenuItem
    name string
}

// NewMenuItem creates a new menu item
func NewMenuItem(label, action string) *MenuItem {
    cLabel := C.CString(label)
    defer C.free(unsafe.Pointer(cLabel))
    
    cAction := C.CString(action)
    defer C.free(unsafe.Pointer(cAction))
    
    item := C.create_menu_item(cLabel, cAction)
    
    return &MenuItem{
        item: item,
        name: action,
    }
}

// GetNative returns the underlying GMenuItem pointer
func (mi *MenuItem) GetNative() *C.GMenuItem {
    return mi.item
}

// GetName returns the action name of the menu item
func (mi *MenuItem) GetName() string {
    return mi.name
}

// Menu represents a GTK menu
type Menu struct {
    menu *C.GMenu
}

// NewMenu creates a new GTK menu
func NewMenu() *Menu {
    menu := &Menu{
        menu: C.create_menu(),
    }
    return menu
}

// AppendItem adds a menu item to the menu
func (m *Menu) AppendItem(item *MenuItem) {
    C.append_item_to_menu(m.menu, item.item)
}

// AppendSubmenu adds a submenu to the menu
func (m *Menu) AppendSubmenu(label string, submenu *Menu) {
    cLabel := C.CString(label)
    defer C.free(unsafe.Pointer(cLabel))
    
    C.append_submenu_to_menu(m.menu, cLabel, submenu.menu)
}

// GetMenuModel returns the underlying GMenuModel
func (m *Menu) GetMenuModel() *C.GMenuModel {
    return (*C.GMenuModel)(unsafe.Pointer(m.menu))
}

// GetNative returns the underlying GMenu pointer for callback registration
func (m *Menu) GetNative() uintptr {
    return uintptr(unsafe.Pointer(m.menu))
}

// MenuBar represents a GTK menu bar
type MenuBar struct {
    BaseWidget
}

// NewMenuBar creates a new GTK menu bar
func NewMenuBar() *MenuBar {
    menuBar := &MenuBar{
        BaseWidget: BaseWidget{
            widget: C.gtk_popover_menu_bar_new_from_model(nil),
        },
    }

    SetupFinalization(menuBar, menuBar.Destroy)
    return menuBar
}

// SetMenuModel sets the menu model for the menu bar
func (mb *MenuBar) SetMenuModel(menu *Menu) {
    C.gtk_popover_menu_bar_set_menu_model(
        (*C.GtkPopoverMenuBar)(unsafe.Pointer(mb.widget)),
        menu.GetMenuModel(),
    )
}

// ConnectSelectionChanged connects a callback for selection changes in the menu bar
func (mb *MenuBar) ConnectSelectionChanged(callback func()) {
    Connect(mb, SignalSelectionChanged, callback)
}

// PopoverMenu represents a GTK popover menu
type PopoverMenu struct {
    BaseWidget
}

// NewPopoverMenu creates a new GTK popover menu from a menu model
func NewPopoverMenu(menu *Menu) *PopoverMenu {
    popoverMenu := &PopoverMenu{
        BaseWidget: BaseWidget{
            widget: C.create_popover_menu_from_model(menu.GetMenuModel()),
        },
    }

    SetupFinalization(popoverMenu, popoverMenu.Destroy)
    return popoverMenu
}

// SetMenuModel sets the menu model for the popover menu
func (pm *PopoverMenu) SetMenuModel(menu *Menu) {
    C.set_popover_menu_model(
        (*C.GtkPopoverMenu)(unsafe.Pointer(pm.widget)),
        menu.GetMenuModel(),
    )
}

// SetParent sets the parent widget for the popover
func (pm *PopoverMenu) SetParent(parent Widget) {
    C.set_popover_parent(
        (*C.GtkPopover)(unsafe.Pointer(pm.widget)),
        parent.GetWidget(),
    )
}

// Popup shows the popover
func (pm *PopoverMenu) Popup() {
    C.gtk_popover_popup((*C.GtkPopover)(unsafe.Pointer(pm.widget)))
}

// Popdown hides the popover
func (pm *PopoverMenu) Popdown() {
    C.gtk_popover_popdown((*C.GtkPopover)(unsafe.Pointer(pm.widget)))
}

// ConnectDeactivate connects a callback for when the popover is closed
func (pm *PopoverMenu) ConnectDeactivate(callback func()) {
    Connect(pm, SignalDeactivate, callback)
}

// Destroy overrides BaseWidget's Destroy to clean up resources
func (pm *PopoverMenu) Destroy() {
    // Clean up all callbacks using the unified system
    DisconnectAll(pm)
    
    // Call the base method
    pm.BaseWidget.Destroy()
}

// MenuButton represents a GTK menu button
type MenuButton struct {
    BaseWidget
}

// NewMenuButton creates a new GTK menu button
func NewMenuButton() *MenuButton {
    menuButton := &MenuButton{
        BaseWidget: BaseWidget{
            widget: C.gtk_menu_button_new(),
        },
    }

    SetupFinalization(menuButton, menuButton.Destroy)
    return menuButton
}

// SetMenuModel sets the menu model for the menu button
func (mb *MenuButton) SetMenuModel(menu *Menu) {
    C.gtk_menu_button_set_menu_model(
        (*C.GtkMenuButton)(unsafe.Pointer(mb.widget)),
        menu.GetMenuModel(),
    )
}

// SetLabel sets the label for the menu button
func (mb *MenuButton) SetLabel(label string) {
    cLabel := C.CString(label)
    defer C.free(unsafe.Pointer(cLabel))
    
    C.gtk_menu_button_set_label(
        (*C.GtkMenuButton)(unsafe.Pointer(mb.widget)),
        cLabel,
    )
}

// SetPopover sets a popover for the menu button
func (mb *MenuButton) SetPopover(popover *PopoverMenu) {
    C.gtk_menu_button_set_popover(
        (*C.GtkMenuButton)(unsafe.Pointer(mb.widget)),
        popover.widget,
    )
}

// Destroy overrides BaseWidget's Destroy to clean up resources
func (mb *MenuButton) Destroy() {
    // Clean up all callbacks using the unified system
    DisconnectAll(mb)
    
    // Call the base method
    mb.BaseWidget.Destroy()
}

############################################################
# File: gtk4/paned.go
############################################################

// Package gtk4 provides paned container functionality for GTK4
// File: gtk4go/gtk4/paned.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// PanedOption is a function that configures a paned container
type PanedOption func(*Paned)

// Paned represents a GTK paned container (a split view)
type Paned struct {
	BaseWidget
}

// NewPaned creates a new GTK paned container with the given orientation
func NewPaned(orientation Orientation, options ...PanedOption) *Paned {
	paned := &Paned{
		BaseWidget: BaseWidget{
			widget: C.gtk_paned_new(C.GtkOrientation(orientation)),
		},
	}

	// Apply options
	for _, option := range options {
		option(paned)
	}

	SetupFinalization(paned, paned.Destroy)
	return paned
}

// WithPosition sets the initial position of the divider
func WithPosition(position int) PanedOption {
	return func(p *Paned) {
		C.gtk_paned_set_position((*C.GtkPaned)(unsafe.Pointer(p.widget)), C.int(position))
	}
}

// WithWideHandle sets whether to use a wide handle
func WithWideHandle(wide bool) PanedOption {
	return func(p *Paned) {
		var cwide C.gboolean
		if wide {
			cwide = C.TRUE
		} else {
			cwide = C.FALSE
		}
		C.gtk_paned_set_wide_handle((*C.GtkPaned)(unsafe.Pointer(p.widget)), cwide)
	}
}

// SetStartChild sets the start (top/left) child widget
func (p *Paned) SetStartChild(child Widget) {
	C.gtk_paned_set_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), child.GetWidget())
}

// SetEndChild sets the end (bottom/right) child widget
func (p *Paned) SetEndChild(child Widget) {
	C.gtk_paned_set_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), child.GetWidget())
}

// GetStartChild gets the start child widget
func (p *Paned) GetStartChild() Widget {
	widget := C.gtk_paned_get_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget)))
	// Similar to Grid.GetChildAt, we need a proper implementation to convert to Widget
	if widget == nil {
		return nil
	}
	return nil
}

// GetEndChild gets the end child widget
func (p *Paned) GetEndChild() Widget {
	widget := C.gtk_paned_get_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget)))
	// Similar to Grid.GetChildAt, we need a proper implementation to convert to Widget
	if widget == nil {
		return nil
	}
	return nil
}

// SetPosition sets the position of the divider
func (p *Paned) SetPosition(position int) {
	C.gtk_paned_set_position((*C.GtkPaned)(unsafe.Pointer(p.widget)), C.int(position))
}

// GetPosition gets the position of the divider
func (p *Paned) GetPosition() int {
	return int(C.gtk_paned_get_position((*C.GtkPaned)(unsafe.Pointer(p.widget))))
}

// SetWideHandle sets whether to use a wide handle
func (p *Paned) SetWideHandle(wide bool) {
	var cwide C.gboolean
	if wide {
		cwide = C.TRUE
	} else {
		cwide = C.FALSE
	}
	C.gtk_paned_set_wide_handle((*C.GtkPaned)(unsafe.Pointer(p.widget)), cwide)
}

// GetWideHandle gets whether a wide handle is used
func (p *Paned) GetWideHandle() bool {
	return C.gtk_paned_get_wide_handle((*C.GtkPaned)(unsafe.Pointer(p.widget))) == C.TRUE
}

// SetStartChildResizable sets whether the start child is resizable
func (p *Paned) SetStartChildResizable(resizable bool) {
	var cresizable C.gboolean
	if resizable {
		cresizable = C.TRUE
	} else {
		cresizable = C.FALSE
	}
	C.gtk_paned_set_resize_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), cresizable)
}

// GetStartChildResizable gets whether the start child is resizable
func (p *Paned) GetStartChildResizable() bool {
	return C.gtk_paned_get_resize_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget))) == C.TRUE
}

// SetEndChildResizable sets whether the end child is resizable
func (p *Paned) SetEndChildResizable(resizable bool) {
	var cresizable C.gboolean
	if resizable {
		cresizable = C.TRUE
	} else {
		cresizable = C.FALSE
	}
	C.gtk_paned_set_resize_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), cresizable)
}

// GetEndChildResizable gets whether the end child is resizable
func (p *Paned) GetEndChildResizable() bool {
	return C.gtk_paned_get_resize_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget))) == C.TRUE
}

// SetShrinkStartChild sets whether the start child can be made smaller than its requisition
func (p *Paned) SetShrinkStartChild(shrink bool) {
	var cshrink C.gboolean
	if shrink {
		cshrink = C.TRUE
	} else {
		cshrink = C.FALSE
	}
	C.gtk_paned_set_shrink_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), cshrink)
}

// GetShrinkStartChild gets whether the start child can be made smaller than its requisition
func (p *Paned) GetShrinkStartChild() bool {
	return C.gtk_paned_get_shrink_start_child((*C.GtkPaned)(unsafe.Pointer(p.widget))) == C.TRUE
}

// SetShrinkEndChild sets whether the end child can be made smaller than its requisition
func (p *Paned) SetShrinkEndChild(shrink bool) {
	var cshrink C.gboolean
	if shrink {
		cshrink = C.TRUE
	} else {
		cshrink = C.FALSE
	}
	C.gtk_paned_set_shrink_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget)), cshrink)
}

// GetShrinkEndChild gets whether the end child can be made smaller than its requisition
func (p *Paned) GetShrinkEndChild() bool {
	return C.gtk_paned_get_shrink_end_child((*C.GtkPaned)(unsafe.Pointer(p.widget))) == C.TRUE
}


############################################################
# File: gtk4/scrolledWindow.go
############################################################

// Package gtk4 provides scrolled window functionality for GTK4
// File: gtk4go/gtk4/scrolledWindow.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// ScrollbarPolicyType defines the visibility policy for scrollbars
type ScrollbarPolicyType int

const (
	// ScrollbarPolicyAlways always shows scrollbars
	ScrollbarPolicyAlways ScrollbarPolicyType = C.GTK_POLICY_ALWAYS
	// ScrollbarPolicyAutomatic shows scrollbars when needed
	ScrollbarPolicyAutomatic ScrollbarPolicyType = C.GTK_POLICY_AUTOMATIC
	// ScrollbarPolicyNever never shows scrollbars
	ScrollbarPolicyNever ScrollbarPolicyType = C.GTK_POLICY_NEVER
)

// ScrolledWindowOption is a function that configures a scrolled window
type ScrolledWindowOption func(*ScrolledWindow)

// ScrolledWindow represents a GTK scrolled window container
type ScrolledWindow struct {
	BaseWidget
}

// NewScrolledWindow creates a new GTK scrolled window container
func NewScrolledWindow(options ...ScrolledWindowOption) *ScrolledWindow {
	scrolledWindow := &ScrolledWindow{
		BaseWidget: BaseWidget{
			widget: C.gtk_scrolled_window_new(),
		},
	}

	// Apply options
	for _, option := range options {
		option(scrolledWindow)
	}

	SetupFinalization(scrolledWindow, scrolledWindow.Destroy)
	return scrolledWindow
}

// WithHScrollbarPolicy sets the horizontal scrollbar policy
func WithHScrollbarPolicy(policy ScrollbarPolicyType) ScrolledWindowOption {
	return func(sw *ScrolledWindow) {
		sw.SetHScrollbarPolicy(policy)
	}
}

// WithVScrollbarPolicy sets the vertical scrollbar policy
func WithVScrollbarPolicy(policy ScrollbarPolicyType) ScrolledWindowOption {
	return func(sw *ScrolledWindow) {
		sw.SetVScrollbarPolicy(policy)
	}
}

// WithPropagateNaturalWidth sets whether to propagate the natural width of the child
func WithPropagateNaturalWidth(propagate bool) ScrolledWindowOption {
	return func(sw *ScrolledWindow) {
		var cpropagate C.gboolean
		if propagate {
			cpropagate = C.TRUE
		} else {
			cpropagate = C.FALSE
		}
		C.gtk_scrolled_window_set_propagate_natural_width(
			(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
			cpropagate,
		)
	}
}

// WithPropagateNaturalHeight sets whether to propagate the natural height of the child
func WithPropagateNaturalHeight(propagate bool) ScrolledWindowOption {
	return func(sw *ScrolledWindow) {
		var cpropagate C.gboolean
		if propagate {
			cpropagate = C.TRUE
		} else {
			cpropagate = C.FALSE
		}
		C.gtk_scrolled_window_set_propagate_natural_height(
			(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
			cpropagate,
		)
	}
}

// SetChild sets the child widget of the scrolled window
func (sw *ScrolledWindow) SetChild(child Widget) {
	C.gtk_scrolled_window_set_child(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
		child.GetWidget(),
	)
}

// GetChild gets the child widget of the scrolled window
func (sw *ScrolledWindow) GetChild() Widget {
	widget := C.gtk_scrolled_window_get_child((*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)))

	// Similar to Grid.GetChildAt, we need a proper implementation to convert to Widget
	if widget == nil {
		return nil
	}
	return nil
}

// SetPolicy sets the policy for both horizontal and vertical scrollbars
func (sw *ScrolledWindow) SetPolicy(hPolicy, vPolicy ScrollbarPolicyType) {
	C.gtk_scrolled_window_set_policy(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
		C.GtkPolicyType(hPolicy),
		C.GtkPolicyType(vPolicy),
	)
}

// SetHScrollbarPolicy sets the horizontal scrollbar policy
func (sw *ScrolledWindow) SetHScrollbarPolicy(policy ScrollbarPolicyType) {
	_, vPolicy := sw.GetPolicy()
	sw.SetPolicy(policy, vPolicy)
}

// SetVScrollbarPolicy sets the vertical scrollbar policy
func (sw *ScrolledWindow) SetVScrollbarPolicy(policy ScrollbarPolicyType) {
	hPolicy, _ := sw.GetPolicy()
	sw.SetPolicy(hPolicy, policy)
}

// GetPolicy gets the policy for both horizontal and vertical scrollbars
func (sw *ScrolledWindow) GetPolicy() (hPolicy, vPolicy ScrollbarPolicyType) {
	var chPolicy, cvPolicy C.GtkPolicyType
	C.gtk_scrolled_window_get_policy(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
		&chPolicy,
		&cvPolicy,
	)
	return ScrollbarPolicyType(chPolicy), ScrollbarPolicyType(cvPolicy)
}

// SetPropagateNaturalWidth sets whether to propagate the natural width of the child
func (sw *ScrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var cpropagate C.gboolean
	if propagate {
		cpropagate = C.TRUE
	} else {
		cpropagate = C.FALSE
	}
	C.gtk_scrolled_window_set_propagate_natural_width(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
		cpropagate,
	)
}

// GetPropagateNaturalWidth gets whether the natural width of the child is propagated
func (sw *ScrolledWindow) GetPropagateNaturalWidth() bool {
	return C.gtk_scrolled_window_get_propagate_natural_width(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
	) == C.TRUE
}

// SetPropagateNaturalHeight sets whether to propagate the natural height of the child
func (sw *ScrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var cpropagate C.gboolean
	if propagate {
		cpropagate = C.TRUE
	} else {
		cpropagate = C.FALSE
	}
	C.gtk_scrolled_window_set_propagate_natural_height(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
		cpropagate,
	)
}

// GetPropagateNaturalHeight gets whether the natural height of the child is propagated
func (sw *ScrolledWindow) GetPropagateNaturalHeight() bool {
	return C.gtk_scrolled_window_get_propagate_natural_height(
		(*C.GtkScrolledWindow)(unsafe.Pointer(sw.widget)),
	) == C.TRUE
}


############################################################
# File: gtk4/selectionModel.go
############################################################

// Package gtk4 provides selection model functionality for GTK4
// File: gtk4go/gtk4/selectionmodel.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Selection model callbacks
// extern void selectionChangedCallback(GtkSelectionModel *model, guint position, guint n_items, gpointer user_data);
//
// // Connect selection changed signal
// static gulong connectSelectionChanged(GtkSelectionModel *model, gpointer user_data) {
//     return g_signal_connect(model, "selection-changed", G_CALLBACK(selectionChangedCallback), user_data);
// }
//
// // SingleSelection operations
// static GtkSingleSelection* createSingleSelection(GListModel *model) {
//     return gtk_single_selection_new(model);
// }
//
// static void setSingleSelectionModel(GtkSingleSelection *selection, GListModel *model) {
//     gtk_single_selection_set_model(selection, model);
// }
//
// static void setSingleSelectionSelected(GtkSingleSelection *selection, guint position) {
//     gtk_single_selection_set_selected(selection, position);
// }
//
// static guint getSingleSelectionSelected(GtkSingleSelection *selection) {
//     return gtk_single_selection_get_selected(selection);
// }
//
// static void setSingleSelectionAutoselect(GtkSingleSelection *selection, gboolean autoselect) {
//     gtk_single_selection_set_autoselect(selection, autoselect);
// }
//
// static gboolean getSingleSelectionAutoselect(GtkSingleSelection *selection) {
//     return gtk_single_selection_get_autoselect(selection);
// }
//
// // MultiSelection operations
// static GtkMultiSelection* createMultiSelection(GListModel *model) {
//     return gtk_multi_selection_new(model);
// }
//
// static void setMultiSelectionModel(GtkMultiSelection *selection, GListModel *model) {
//     gtk_multi_selection_set_model(selection, model);
// }
//
// // NoSelection operations
// static GtkNoSelection* createNoSelection(GListModel *model) {
//     return gtk_no_selection_new(model);
// }
//
// static void setNoSelectionModel(GtkNoSelection *selection, GListModel *model) {
//     gtk_no_selection_set_model(selection, model);
// }
//
// // Common selection model operations
// static gboolean selectionModelIsSelected(GtkSelectionModel *model, guint position) {
//     return gtk_selection_model_is_selected(model, position);
// }
//
// static GtkBitset* selectionModelGetSelection(GtkSelectionModel *model) {
//     return gtk_selection_model_get_selection(model);
// }
//
// static void selectionModelSelectItem(GtkSelectionModel *model, guint position, gboolean unselect_rest) {
//     gtk_selection_model_select_item(model, position, unselect_rest);
// }
//
// static void selectionModelUnselectItem(GtkSelectionModel *model, guint position) {
//     gtk_selection_model_unselect_item(model, position);
// }
//
// static void selectionModelSelectRange(GtkSelectionModel *model, guint position, guint n_items, gboolean unselect_rest) {
//     gtk_selection_model_select_range(model, position, n_items, unselect_rest);
// }
//
// static void selectionModelUnselectRange(GtkSelectionModel *model, guint position, guint n_items) {
//     gtk_selection_model_unselect_range(model, position, n_items);
// }
//
// static void selectionModelSelectAll(GtkSelectionModel *model) {
//     gtk_selection_model_select_all(model);
// }
//
// static void selectionModelUnselectAll(GtkSelectionModel *model) {
//     gtk_selection_model_unselect_all(model);
// }
import "C"

import (
	"runtime"
	"sync"
	"unsafe"
)

// SelectionChangedCallback represents a callback for selection changes
type SelectionChangedCallback func(position, nItems int)

var (
	selectionCallbacks     = make(map[uintptr]SelectionChangedCallback)
	selectionCallbackMutex sync.RWMutex
)

//export selectionChangedCallback
func selectionChangedCallback(model *C.GtkSelectionModel, position, nItems C.guint, userData C.gpointer) {
	selectionCallbackMutex.RLock()
	defer selectionCallbackMutex.RUnlock()

	// Convert model pointer to uintptr for lookup
	modelPtr := uintptr(unsafe.Pointer(model))

	// Find and call the callback
	if callback, ok := selectionCallbacks[modelPtr]; ok {
		callback(int(position), int(nItems))
	}
}

// SelectionModel is an interface for GTK selection models
type SelectionModel interface {
	ListModel

	// GetSelectionModel returns the underlying GtkSelectionModel pointer
	GetSelectionModel() *C.GtkSelectionModel

	// IsSelected returns whether the item at the given position is selected
	IsSelected(position int) bool

	// SelectItem selects the item at the given position
	SelectItem(position int, unselectRest bool)

	// UnselectItem unselects the item at the given position
	UnselectItem(position int)

	// SelectRange selects a range of items
	SelectRange(position, nItems int, unselectRest bool)

	// UnselectRange unselects a range of items
	UnselectRange(position, nItems int)

	// SelectAll selects all items
	SelectAll()

	// UnselectAll unselects all items
	UnselectAll()

	// ConnectSelectionChanged connects a callback for selection changes
	ConnectSelectionChanged(callback SelectionChangedCallback)
}

// BaseSelectionModel provides common functionality for selection models
type BaseSelectionModel struct {
	BaseListModel
	selectionModel *C.GtkSelectionModel
	sourceModel    ListModel // The source model for this selection model
}

// GetSelectionModel returns the underlying GtkSelectionModel pointer
func (m *BaseSelectionModel) GetSelectionModel() *C.GtkSelectionModel {
	return m.selectionModel
}

// IsSelected returns whether the item at the given position is selected
func (m *BaseSelectionModel) IsSelected(position int) bool {
	return C.selectionModelIsSelected(m.selectionModel, C.guint(position)) != 0
}

// SelectItem selects the item at the given position
func (m *BaseSelectionModel) SelectItem(position int, unselectRest bool) {
	var cunselectRest C.gboolean
	if unselectRest {
		cunselectRest = C.TRUE
	} else {
		cunselectRest = C.FALSE
	}
	C.selectionModelSelectItem(m.selectionModel, C.guint(position), cunselectRest)
}

// UnselectItem unselects the item at the given position
func (m *BaseSelectionModel) UnselectItem(position int) {
	C.selectionModelUnselectItem(m.selectionModel, C.guint(position))
}

// SelectRange selects a range of items
func (m *BaseSelectionModel) SelectRange(position, nItems int, unselectRest bool) {
	var cunselectRest C.gboolean
	if unselectRest {
		cunselectRest = C.TRUE
	} else {
		cunselectRest = C.FALSE
	}
	C.selectionModelSelectRange(m.selectionModel, C.guint(position), C.guint(nItems), cunselectRest)
}

// UnselectRange unselects a range of items
func (m *BaseSelectionModel) UnselectRange(position, nItems int) {
	C.selectionModelUnselectRange(m.selectionModel, C.guint(position), C.guint(nItems))
}

// SelectAll selects all items
func (m *BaseSelectionModel) SelectAll() {
	C.selectionModelSelectAll(m.selectionModel)
}

// UnselectAll unselects all items
func (m *BaseSelectionModel) UnselectAll() {
	C.selectionModelUnselectAll(m.selectionModel)
}

// GetItem returns the item at the given position by delegating to the source model
func (m *BaseSelectionModel) GetItem(position int) interface{} {
	if m.sourceModel != nil {
		return m.sourceModel.GetItem(position)
	}
	// Fallback to the BaseListModel implementation if no source model
	return m.BaseListModel.GetItem(position)
}

// ConnectSelectionChanged connects a callback for selection changes
func (m *BaseSelectionModel) ConnectSelectionChanged(callback SelectionChangedCallback) {
	if callback == nil {
		return
	}

	selectionCallbackMutex.Lock()
	defer selectionCallbackMutex.Unlock()

	// Store the callback in the map
	modelPtr := uintptr(unsafe.Pointer(m.selectionModel))
	selectionCallbacks[modelPtr] = callback

	// Connect the signal
	C.connectSelectionChanged(m.selectionModel, C.gpointer(unsafe.Pointer(m.selectionModel)))
}

// Destroy frees resources associated with the selection model
func (m *BaseSelectionModel) Destroy() {
	if m.selectionModel != nil {
		selectionCallbackMutex.Lock()
		delete(selectionCallbacks, uintptr(unsafe.Pointer(m.selectionModel)))
		selectionCallbackMutex.Unlock()
	}

	m.BaseListModel.Destroy()
	m.selectionModel = nil
	m.sourceModel = nil
}

// SingleSelection is a selection model that allows selecting a single item
type SingleSelection struct {
	BaseSelectionModel
	singleSelection *C.GtkSingleSelection
}

// SingleSelectionOption is a function that configures a single selection
type SingleSelectionOption func(*SingleSelection)

// NewSingleSelection creates a new single selection model
func NewSingleSelection(model ListModel, options ...SingleSelectionOption) *SingleSelection {
	var singleSelection *C.GtkSingleSelection
	if model != nil {
		singleSelection = C.createSingleSelection(model.GetListModel())
	} else {
		singleSelection = C.createSingleSelection(nil)
	}

	selection := &SingleSelection{
		BaseSelectionModel: BaseSelectionModel{
			BaseListModel: BaseListModel{
				model: (*C.GListModel)(unsafe.Pointer(singleSelection)),
			},
			selectionModel: (*C.GtkSelectionModel)(unsafe.Pointer(singleSelection)),
			sourceModel:    model,
		},
		singleSelection: singleSelection,
	}

	// Apply options
	for _, option := range options {
		option(selection)
	}

	runtime.SetFinalizer(selection, (*SingleSelection).Destroy)
	return selection
}

// WithAutoselect sets whether the selection should automatically select an item
func WithAutoselect(autoselect bool) SingleSelectionOption {
	return func(s *SingleSelection) {
		var cautoselect C.gboolean
		if autoselect {
			cautoselect = C.TRUE
		} else {
			cautoselect = C.FALSE
		}
		C.setSingleSelectionAutoselect(s.singleSelection, cautoselect)
	}
}

// WithInitialSelection sets the initially selected item
func WithInitialSelection(position int) SingleSelectionOption {
	return func(s *SingleSelection) {
		C.setSingleSelectionSelected(s.singleSelection, C.guint(position))
	}
}

// SetModel sets the model for the selection
func (s *SingleSelection) SetModel(model ListModel) {
	if model != nil {
		C.setSingleSelectionModel(s.singleSelection, model.GetListModel())
		s.sourceModel = model
	} else {
		C.setSingleSelectionModel(s.singleSelection, nil)
		s.sourceModel = nil
	}
}

// GetSelected returns the position of the selected item
func (s *SingleSelection) GetSelected() int {
	return int(C.getSingleSelectionSelected(s.singleSelection))
}

// SetSelected sets the selected item
func (s *SingleSelection) SetSelected(position int) {
	C.setSingleSelectionSelected(s.singleSelection, C.guint(position))
}

// SetAutoselect sets whether the selection should automatically select an item
func (s *SingleSelection) SetAutoselect(autoselect bool) {
	var cautoselect C.gboolean
	if autoselect {
		cautoselect = C.TRUE
	} else {
		cautoselect = C.FALSE
	}
	C.setSingleSelectionAutoselect(s.singleSelection, cautoselect)
}

// GetAutoselect returns whether the selection automatically selects an item
func (s *SingleSelection) GetAutoselect() bool {
	return C.getSingleSelectionAutoselect(s.singleSelection) != 0
}

// GetItem delegates to the source model to get an item at a specific position
func (s *SingleSelection) GetItem(position int) interface{} {
	return s.BaseSelectionModel.GetItem(position)
}

// Destroy frees resources associated with the single selection
func (s *SingleSelection) Destroy() {
	s.BaseSelectionModel.Destroy()
	s.singleSelection = nil
}

// MultiSelection is a selection model that allows selecting multiple items
type MultiSelection struct {
	BaseSelectionModel
	multiSelection *C.GtkMultiSelection
}

// NewMultiSelection creates a new multi-selection model
func NewMultiSelection(model ListModel) *MultiSelection {
	var multiSelection *C.GtkMultiSelection
	if model != nil {
		multiSelection = C.createMultiSelection(model.GetListModel())
	} else {
		multiSelection = C.createMultiSelection(nil)
	}

	selection := &MultiSelection{
		BaseSelectionModel: BaseSelectionModel{
			BaseListModel: BaseListModel{
				model: (*C.GListModel)(unsafe.Pointer(multiSelection)),
			},
			selectionModel: (*C.GtkSelectionModel)(unsafe.Pointer(multiSelection)),
			sourceModel:    model,
		},
		multiSelection: multiSelection,
	}

	runtime.SetFinalizer(selection, (*MultiSelection).Destroy)
	return selection
}

// SetModel sets the model for the selection
func (s *MultiSelection) SetModel(model ListModel) {
	if model != nil {
		C.setMultiSelectionModel(s.multiSelection, model.GetListModel())
		s.sourceModel = model
	} else {
		C.setMultiSelectionModel(s.multiSelection, nil)
		s.sourceModel = nil
	}
}

// GetItem delegates to the source model to get an item at a specific position
func (s *MultiSelection) GetItem(position int) interface{} {
	return s.BaseSelectionModel.GetItem(position)
}

// Destroy frees resources associated with the multi selection
func (s *MultiSelection) Destroy() {
	s.BaseSelectionModel.Destroy()
	s.multiSelection = nil
}

// NoSelection is a selection model that doesn't allow selecting items
type NoSelection struct {
	BaseSelectionModel
	noSelection *C.GtkNoSelection
}

// NewNoSelection creates a new no-selection model
func NewNoSelection(model ListModel) *NoSelection {
	var noSelection *C.GtkNoSelection
	if model != nil {
		noSelection = C.createNoSelection(model.GetListModel())
	} else {
		noSelection = C.createNoSelection(nil)
	}

	selection := &NoSelection{
		BaseSelectionModel: BaseSelectionModel{
			BaseListModel: BaseListModel{
				model: (*C.GListModel)(unsafe.Pointer(noSelection)),
			},
			selectionModel: (*C.GtkSelectionModel)(unsafe.Pointer(noSelection)),
			sourceModel:    model,
		},
		noSelection: noSelection,
	}

	runtime.SetFinalizer(selection, (*NoSelection).Destroy)
	return selection
}

// SetModel sets the model for the selection
func (s *NoSelection) SetModel(model ListModel) {
	if model != nil {
		C.setNoSelectionModel(s.noSelection, model.GetListModel())
		s.sourceModel = model
	} else {
		C.setNoSelectionModel(s.noSelection, nil)
		s.sourceModel = nil
	}
}

// GetItem delegates to the source model to get an item at a specific position
func (s *NoSelection) GetItem(position int) interface{} {
	return s.BaseSelectionModel.GetItem(position)
}

// Destroy frees resources associated with the no selection
func (s *NoSelection) Destroy() {
	s.BaseSelectionModel.Destroy()
	s.noSelection = nil
}

############################################################
# File: gtk4/stack.go
############################################################

// Package gtk4 provides stack container functionality for GTK4
// File: gtk4go/gtk4/stack.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// StackTransitionType defines the type of animation used when transitioning between pages in a Stack
type StackTransitionType int

const (
	// StackTransitionTypeNone no transition
	StackTransitionTypeNone StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_NONE
	// StackTransitionTypeCrossfade crossfade transition
	StackTransitionTypeCrossfade StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_CROSSFADE
	// StackTransitionTypeSlideRight slide from left to right
	StackTransitionTypeSlideRight StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT
	// StackTransitionTypeSlideLeft slide from right to left
	StackTransitionTypeSlideLeft StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT
	// StackTransitionTypeSlideUp slide from bottom to top
	StackTransitionTypeSlideUp StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_UP
	// StackTransitionTypeSlideDown slide from top to bottom
	StackTransitionTypeSlideDown StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN
	// StackTransitionTypeSlideLeftRight slide from left or right according to the children order
	StackTransitionTypeSlideLeftRight StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT
	// StackTransitionTypeSlideUpDown slide from top or bottom according to the children order
	StackTransitionTypeSlideUpDown StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN
	// StackTransitionTypeOverUp slide the new widget over the old one from bottom to top
	StackTransitionTypeOverUp StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_UP
	// StackTransitionTypeOverDown slide the new widget over the old one from top to bottom
	StackTransitionTypeOverDown StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_DOWN
	// StackTransitionTypeOverLeft slide the new widget over the old one from right to left
	StackTransitionTypeOverLeft StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_LEFT
	// StackTransitionTypeOverRight slide the new widget over the old one from left to right
	StackTransitionTypeOverRight StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_RIGHT
	// StackTransitionTypeUnderUp slide the old widget under the new one from bottom to top
	StackTransitionTypeUnderUp StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_UNDER_UP
	// StackTransitionTypeUnderDown slide the old widget under the new one from top to bottom
	StackTransitionTypeUnderDown StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_UNDER_DOWN
	// StackTransitionTypeUnderLeft slide the old widget under the new one from right to left
	StackTransitionTypeUnderLeft StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_UNDER_LEFT
	// StackTransitionTypeUnderRight slide the old widget under the new one from left to right
	StackTransitionTypeUnderRight StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT
	// StackTransitionTypeOverUpDown slide the new widget over the old one from bottom or top according to the order
	StackTransitionTypeOverUpDown StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN
	// StackTransitionTypeOverDownUp slide the new widget over the old one from top or bottom according to the order
	StackTransitionTypeOverDownUp StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP
	// StackTransitionTypeOverLeftRight slide the new widget over the old one from right or left according to the order
	StackTransitionTypeOverLeftRight StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT
	// StackTransitionTypeOverRightLeft slide the new widget over the old one from left or right according to the order
	StackTransitionTypeOverRightLeft StackTransitionType = C.GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT
)

// StackOption is a function that configures a stack
type StackOption func(*Stack)

// Stack represents a GTK stack container
type Stack struct {
	BaseWidget
}

// NewStack creates a new GTK stack container
func NewStack(options ...StackOption) *Stack {
	stack := &Stack{
		BaseWidget: BaseWidget{
			widget: C.gtk_stack_new(),
		},
	}

	// Apply options
	for _, option := range options {
		option(stack)
	}

	SetupFinalization(stack, stack.Destroy)
	return stack
}

// WithTransitionType sets the transition type
func WithTransitionType(transitionType StackTransitionType) StackOption {
	return func(s *Stack) {
		C.gtk_stack_set_transition_type(
			(*C.GtkStack)(unsafe.Pointer(s.widget)),
			C.GtkStackTransitionType(transitionType),
		)
	}
}

// WithTransitionDuration sets the transition duration
func WithTransitionDuration(duration uint) StackOption {
	return func(s *Stack) {
		C.gtk_stack_set_transition_duration(
			(*C.GtkStack)(unsafe.Pointer(s.widget)),
			C.guint(duration),
		)
	}
}

// WithHHomogeneous sets whether all children have the same width
func WithHHomogeneous(homogeneous bool) StackOption {
	return func(s *Stack) {
		var chomogeneous C.gboolean
		if homogeneous {
			chomogeneous = C.TRUE
		} else {
			chomogeneous = C.FALSE
		}
		C.gtk_stack_set_hhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget)), chomogeneous)
	}
}

// WithVHomogeneous sets whether all children have the same height
func WithVHomogeneous(homogeneous bool) StackOption {
	return func(s *Stack) {
		var chomogeneous C.gboolean
		if homogeneous {
			chomogeneous = C.TRUE
		} else {
			chomogeneous = C.FALSE
		}
		C.gtk_stack_set_vhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget)), chomogeneous)
	}
}

// AddNamed adds a child to the stack with the given name
func (s *Stack) AddNamed(child Widget, name string) {
	WithCString(name, func(cName *C.char) {
		C.gtk_stack_add_named(
			(*C.GtkStack)(unsafe.Pointer(s.widget)),
			child.GetWidget(),
			cName,
		)
	})
}

// AddTitled adds a child to the stack with the given name and title
func (s *Stack) AddTitled(child Widget, name, title string) {
	WithCString(name, func(cName *C.char) {
		WithCString(title, func(cTitle *C.char) {
			C.gtk_stack_add_titled(
				(*C.GtkStack)(unsafe.Pointer(s.widget)),
				child.GetWidget(),
				cName,
				cTitle,
			)
		})
	})
}

// Remove removes a child from the stack
func (s *Stack) Remove(child Widget) {
	C.gtk_stack_remove((*C.GtkStack)(unsafe.Pointer(s.widget)), child.GetWidget())
}

// GetChildByName gets the child with the given name
func (s *Stack) GetChildByName(name string) Widget {
	var widget *C.GtkWidget
	WithCString(name, func(cName *C.char) {
		widget = C.gtk_stack_get_child_by_name(
			(*C.GtkStack)(unsafe.Pointer(s.widget)),
			cName,
		)
	})

	if widget == nil {
		return nil
	}

	// Similar to Grid.GetChildAt, we need a proper implementation to convert to Widget
	return nil
}

// SetVisibleChild sets the visible child by widget reference
func (s *Stack) SetVisibleChild(child Widget) {
	C.gtk_stack_set_visible_child(
		(*C.GtkStack)(unsafe.Pointer(s.widget)),
		child.GetWidget(),
	)
}

// SetVisibleChildName sets the visible child by name
func (s *Stack) SetVisibleChildName(name string) {
	WithCString(name, func(cName *C.char) {
		C.gtk_stack_set_visible_child_name(
			(*C.GtkStack)(unsafe.Pointer(s.widget)),
			cName,
		)
	})
}

// GetVisibleChildName gets the name of the visible child
func (s *Stack) GetVisibleChildName() string {
	cName := C.gtk_stack_get_visible_child_name((*C.GtkStack)(unsafe.Pointer(s.widget)))
	if cName == nil {
		return ""
	}
	return C.GoString(cName)
}

// SetTransitionType sets the type of animation used for transitions
func (s *Stack) SetTransitionType(transitionType StackTransitionType) {
	C.gtk_stack_set_transition_type(
		(*C.GtkStack)(unsafe.Pointer(s.widget)),
		C.GtkStackTransitionType(transitionType),
	)
}

// GetTransitionType gets the type of animation used for transitions
func (s *Stack) GetTransitionType() StackTransitionType {
	return StackTransitionType(C.gtk_stack_get_transition_type((*C.GtkStack)(unsafe.Pointer(s.widget))))
}

// SetTransitionDuration sets the duration of the transition in milliseconds
func (s *Stack) SetTransitionDuration(duration uint) {
	C.gtk_stack_set_transition_duration(
		(*C.GtkStack)(unsafe.Pointer(s.widget)),
		C.guint(duration),
	)
}

// GetTransitionDuration gets the duration of the transition in milliseconds
func (s *Stack) GetTransitionDuration() uint {
	return uint(C.gtk_stack_get_transition_duration((*C.GtkStack)(unsafe.Pointer(s.widget))))
}

// SetInterpolateSize sets whether the stack should interpolate its size during transitions
func (s *Stack) SetInterpolateSize(interpolate bool) {
	var cinterpolate C.gboolean
	if interpolate {
		cinterpolate = C.TRUE
	} else {
		cinterpolate = C.FALSE
	}
	C.gtk_stack_set_interpolate_size((*C.GtkStack)(unsafe.Pointer(s.widget)), cinterpolate)
}

// GetInterpolateSize gets whether the stack is set to interpolate its size during transitions
func (s *Stack) GetInterpolateSize() bool {
	return C.gtk_stack_get_interpolate_size((*C.GtkStack)(unsafe.Pointer(s.widget))) == C.TRUE
}

// SetHHomogeneous sets whether the stack allocates the same width for all children
func (s *Stack) SetHHomogeneous(homogeneous bool) {
	var chomogeneous C.gboolean
	if homogeneous {
		chomogeneous = C.TRUE
	} else {
		chomogeneous = C.FALSE
	}
	C.gtk_stack_set_hhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget)), chomogeneous)
}

// GetHHomogeneous gets whether the stack allocates the same width for all children
func (s *Stack) GetHHomogeneous() bool {
	return C.gtk_stack_get_hhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget))) == C.TRUE
}

// SetVHomogeneous sets whether the stack allocates the same height for all children
func (s *Stack) SetVHomogeneous(homogeneous bool) {
	var chomogeneous C.gboolean
	if homogeneous {
		chomogeneous = C.TRUE
	} else {
		chomogeneous = C.FALSE
	}
	C.gtk_stack_set_vhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget)), chomogeneous)
}

// GetVHomogeneous gets whether the stack allocates the same height for all children
func (s *Stack) GetVHomogeneous() bool {
	return C.gtk_stack_get_vhomogeneous((*C.GtkStack)(unsafe.Pointer(s.widget))) == C.TRUE
}


############################################################
# File: gtk4/stackSwitcher.go
############################################################

// Package gtk4 provides stack switcher functionality for GTK4
// File: gtk4go/gtk4/stackSwitcher.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// StackSwitcherOption is a function that configures a stack switcher
type StackSwitcherOption func(*StackSwitcher)

// StackSwitcher represents a GTK stack switcher
type StackSwitcher struct {
	BaseWidget
}

// NewStackSwitcher creates a new GTK stack switcher
func NewStackSwitcher(stack *Stack, options ...StackSwitcherOption) *StackSwitcher {
	switcher := &StackSwitcher{
		BaseWidget: BaseWidget{
			widget: C.gtk_stack_switcher_new(),
		},
	}

	// Set the stack if provided
	if stack != nil {
		C.gtk_stack_switcher_set_stack(
			(*C.GtkStackSwitcher)(unsafe.Pointer(switcher.widget)),
			(*C.GtkStack)(unsafe.Pointer(stack.widget)),
		)
	}

	// Apply options
	for _, option := range options {
		option(switcher)
	}

	SetupFinalization(switcher, switcher.Destroy)
	return switcher
}

// WithStack sets the stack to control
func WithStack(stack *Stack) StackSwitcherOption {
	return func(ss *StackSwitcher) {
		if stack != nil {
			C.gtk_stack_switcher_set_stack(
				(*C.GtkStackSwitcher)(unsafe.Pointer(ss.widget)),
				(*C.GtkStack)(unsafe.Pointer(stack.widget)),
			)
		}
	}
}

// SetStack sets the stack to control
func (ss *StackSwitcher) SetStack(stack *Stack) {
	if stack != nil {
		C.gtk_stack_switcher_set_stack(
			(*C.GtkStackSwitcher)(unsafe.Pointer(ss.widget)),
			(*C.GtkStack)(unsafe.Pointer(stack.widget)),
		)
	}
}

// GetStack gets the stack being controlled
func (ss *StackSwitcher) GetStack() *Stack {
	stackPtr := C.gtk_stack_switcher_get_stack((*C.GtkStackSwitcher)(unsafe.Pointer(ss.widget)))
	if stackPtr == nil {
		return nil
	}

	// Create a new Stack instance wrapping the C pointer
	return &Stack{
		BaseWidget: BaseWidget{
			widget: (*C.GtkWidget)(unsafe.Pointer(stackPtr)),
		},
	}
}


############################################################
# File: gtk4/viewport.go
############################################################

// Package gtk4 provides viewport widget functionality for GTK4
// File: gtk4go/gtk4/viewport.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
import "C"

import (
	"unsafe"
)

// ViewportOption is a function that configures a viewport
type ViewportOption func(*Viewport)

// Viewport represents a GTK viewport container for scrolling
type Viewport struct {
	BaseWidget
}

// NewViewport creates a new GTK viewport container
func NewViewport(options ...ViewportOption) *Viewport {
	// Pass nil for both adjustments - GTK will create default ones
	var hadjustment, vadjustment *C.GtkAdjustment
	hadjustment = nil
	vadjustment = nil

	viewport := &Viewport{
		BaseWidget: BaseWidget{
			widget: C.gtk_viewport_new(hadjustment, vadjustment),
		},
	}

	// Apply options
	for _, option := range options {
		option(viewport)
	}

	SetupFinalization(viewport, viewport.Destroy)
	return viewport
}

// WithScrollToFocus sets whether the viewport should bring a widget into view when it receives focus
func WithScrollToFocus(scroll bool) ViewportOption {
	return func(v *Viewport) {
		var cscroll C.gboolean
		if scroll {
			cscroll = C.TRUE
		} else {
			cscroll = C.FALSE
		}
		C.gtk_viewport_set_scroll_to_focus((*C.GtkViewport)(unsafe.Pointer(v.widget)), cscroll)
	}
}

// SetChild sets the child widget of the viewport
func (v *Viewport) SetChild(child Widget) {
	C.gtk_viewport_set_child((*C.GtkViewport)(unsafe.Pointer(v.widget)), child.GetWidget())
}

// GetChild gets the child widget of the viewport
func (v *Viewport) GetChild() Widget {
	widget := C.gtk_viewport_get_child((*C.GtkViewport)(unsafe.Pointer(v.widget)))

	// Similar to Grid.GetChildAt, we need a proper implementation to convert to Widget
	if widget == nil {
		return nil
	}
	return nil
}

// SetScrollToFocus sets whether the viewport should bring a widget into view when it receives focus
func (v *Viewport) SetScrollToFocus(scroll bool) {
	var cscroll C.gboolean
	if scroll {
		cscroll = C.TRUE
	} else {
		cscroll = C.FALSE
	}
	C.gtk_viewport_set_scroll_to_focus((*C.GtkViewport)(unsafe.Pointer(v.widget)), cscroll)
}

// GetScrollToFocus gets whether the viewport brings a widget into view when it receives focus
func (v *Viewport) GetScrollToFocus() bool {
	return C.gtk_viewport_get_scroll_to_focus((*C.GtkViewport)(unsafe.Pointer(v.widget))) == C.TRUE
}

// ScrollTo scrolls the viewport to make the child widget visible
// Note: In GTK4, scrolling to a specific child is typically handled through
// the parent ScrolledWindow. This is a helper method that finds the
// appropriate scroll adjustments.
func (v *Viewport) ScrollTo(widget Widget) {
	// In GTK4, we need to use the scroll adjustments
	// This is a simplified implementation
	// The exact implementation would depend on the specific use case

	// This method works indirectly by requesting the widget to grab focus,
	// which will trigger scroll_to_focus if it's enabled
	C.gtk_widget_grab_focus(widget.GetWidget())
}


############################################################
# File: gtk4/widgetCCCExtensions.go
############################################################

// Package gtk4 provides widget extension functionality for GTK4
// File: gtk4go/gtk4/widgetCCCExtensions.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Helper function to get gboolean as int
// static int _go_widget_has_css_class(GtkWidget *widget, const char *class_name) {
//     return (int)gtk_widget_has_css_class(widget, class_name);
// }
import "C"

import (
	"unsafe"
)

// AddCssClass adds a CSS class to a widget
func (w *Window) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(w.widget, cClassName)
}

// RemoveCssClass removes a CSS class from a widget
func (w *Window) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(w.widget, cClassName)
}

// HasCssClass checks if a widget has a CSS class
func (w *Window) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C._go_widget_has_css_class(w.widget, cClassName) != 0
}

// AddCssClass adds a CSS class to a widget
func (b *Box) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(b.widget, cClassName)
}

// RemoveCssClass removes a CSS class from a widget
func (b *Box) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(b.widget, cClassName)
}

// HasCssClass checks if a widget has a CSS class
func (b *Box) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C._go_widget_has_css_class(b.widget, cClassName) != 0
}

// AddCssClass adds a CSS class to a widget
func (b *Button) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(b.widget, cClassName)
}

// RemoveCssClass removes a CSS class from a widget
func (b *Button) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(b.widget, cClassName)
}

// HasCssClass checks if a widget has a CSS class
func (b *Button) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C._go_widget_has_css_class(b.widget, cClassName) != 0
}

// AddCssClass adds a CSS class to a widget
func (l *Label) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(l.widget, cClassName)
}

// RemoveCssClass removes a CSS class from a widget
func (l *Label) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(l.widget, cClassName)
}

// HasCssClass checks if a widget has a CSS class
func (l *Label) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C._go_widget_has_css_class(l.widget, cClassName) != 0
}

// AddCssClass adds a CSS class to a widget
func (e *Entry) AddCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_add_css_class(e.widget, cClassName)
}

// RemoveCssClass removes a CSS class from a widget
func (e *Entry) RemoveCssClass(className string) {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	C.gtk_widget_remove_css_class(e.widget, cClassName)
}

// HasCssClass checks if a widget has a CSS class
func (e *Entry) HasCssClass(className string) bool {
	cClassName := C.CString(className)
	defer C.free(unsafe.Pointer(cClassName))
	return C._go_widget_has_css_class(e.widget, cClassName) != 0
}


############################################################
# File: gtk4/window.go
############################################################

// Package gtk4 provides window functionality for GTK4
// File: gtk4go/gtk4/window.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Helper function to enable frame clock synchronization
// static void setWindowRenderingMode(GtkWindow* window) {
//     // Enable hardware acceleration for the window
//     GdkSurface* surface = gtk_native_get_surface(GTK_NATIVE(window));
//     if (surface != NULL) {
//         // Queue surface for rendering - proper way to ensure updates in GTK4
//         gdk_surface_queue_render(surface);
//
//         // In GTK4, we can improve rendering performance by:
//         // 1. Setting frame clock synchronization
//         GdkFrameClock* frame_clock = gdk_surface_get_frame_clock(surface);
//         if (frame_clock != NULL) {
//             // Request updates on the frame clock for smoother animation
//             gdk_frame_clock_begin_updating(frame_clock);
//         }
//     }
// }
//
// // Set content sizing mode for more efficient resizing
// static void setContentSizing(GtkWindow* window) {
//     // Use natural sizing for better resize performance
//     GtkWidget* child = gtk_window_get_child(window);
//     if (child != NULL) {
//         gtk_widget_set_hexpand(child, TRUE);
//         gtk_widget_set_vexpand(child, TRUE);
//     }
// }
import "C"

import (
	"os"
	"unsafe"
)

func init() {
	// Set environment variables to enable hardware acceleration
	// These must be set before the application starts for best effect
	// but we set them here to make sure they're present
	os.Setenv("GSK_RENDERER", "gl")
	os.Setenv("GDK_GL", "always")

	// On some systems, Cairo may be more stable than GL
	// Uncomment if GL causes issues:
	// os.Setenv("GSK_RENDERER", "cairo")
}

// WindowOption is a function that configures a window
type WindowOption func(*Window)

// Window represents a GTK window
type Window struct {
	BaseWidget
	isAcceleratedRendering bool
}

// NewWindow creates a new GTK window with the given title
func NewWindow(title string, options ...WindowOption) *Window {
	window := &Window{
		BaseWidget: BaseWidget{
			widget: C.gtk_window_new(),
		},
		isAcceleratedRendering: true,
	}

	WithCString(title, func(cTitle *C.char) {
		C.gtk_window_set_title((*C.GtkWindow)(unsafe.Pointer(window.widget)), cTitle)
	})

	// Apply default size
	C.gtk_window_set_default_size((*C.GtkWindow)(unsafe.Pointer(window.widget)), 600, 400)

	// Enable hardware acceleration and optimized rendering mode
	window.EnableAcceleratedRendering()

	// Apply options
	for _, option := range options {
		option(window)
	}

	SetupFinalization(window, window.Destroy)
	return window
}

// EnableAcceleratedRendering enables hardware-accelerated rendering and optimizes
// the window for better resize performance
func (w *Window) EnableAcceleratedRendering() {
	if !w.isAcceleratedRendering {
		return
	}

	// Use the C helper function to set up optimal rendering
	C.setWindowRenderingMode((*C.GtkWindow)(unsafe.Pointer(w.widget)))

	// Ensure widget is realized first
	C.gtk_widget_realize(w.widget)
}

// DisableAcceleratedRendering disables hardware acceleration
func (w *Window) DisableAcceleratedRendering() {
	w.isAcceleratedRendering = false
	// Additional code to disable acceleration if needed
}

// OptimizeForResizing applies optimizations specifically for window resizing
func (w *Window) OptimizeForResizing() {
	// Tell GTK to optimize layout calculations during resize
	C.gtk_window_set_resizable((*C.GtkWindow)(unsafe.Pointer(w.widget)), C.TRUE)

	// Configure child widget sizing for better performance
	C.setContentSizing((*C.GtkWindow)(unsafe.Pointer(w.widget)))
}

// WithDefaultSize sets the default window size
func WithDefaultSize(width, height int) WindowOption {
	return func(w *Window) {
		C.gtk_window_set_default_size((*C.GtkWindow)(unsafe.Pointer(w.widget)), C.int(width), C.int(height))
	}
}

// WithTransientFor sets the parent window
func WithTransientFor(parent *Window) WindowOption {
	return func(w *Window) {
		if parent != nil {
			C.gtk_window_set_transient_for(
				(*C.GtkWindow)(unsafe.Pointer(w.widget)),
				(*C.GtkWindow)(unsafe.Pointer(parent.widget)),
			)
		}
	}
}

// WithModal sets whether the window is modal
func WithModal(modal bool) WindowOption {
	return func(w *Window) {
		var cmodal C.gboolean
		if modal {
			cmodal = C.TRUE
		} else {
			cmodal = C.FALSE
		}
		C.gtk_window_set_modal((*C.GtkWindow)(unsafe.Pointer(w.widget)), cmodal)
	}
}

// WithAcceleratedRendering sets whether to use hardware acceleration
func WithAcceleratedRendering(enabled bool) WindowOption {
	return func(w *Window) {
		w.isAcceleratedRendering = enabled
		if enabled {
			w.EnableAcceleratedRendering()
		} else {
			w.DisableAcceleratedRendering()
		}
	}
}

// SetTitle sets the window title
func (w *Window) SetTitle(title string) {
	WithCString(title, func(cTitle *C.char) {
		C.gtk_window_set_title((*C.GtkWindow)(unsafe.Pointer(w.widget)), cTitle)
	})
}

// SetDefaultSize sets the default window size
func (w *Window) SetDefaultSize(width, height int) {
	C.gtk_window_set_default_size((*C.GtkWindow)(unsafe.Pointer(w.widget)), C.int(width), C.int(height))
}

// SetChild sets the child widget for the window
func (w *Window) SetChild(child Widget) {
	C.gtk_window_set_child((*C.GtkWindow)(unsafe.Pointer(w.widget)), child.GetWidget())

	// Re-apply optimization for resizing when child changes
	C.setContentSizing((*C.GtkWindow)(unsafe.Pointer(w.widget)))
}

// Show makes the window visible
func (w *Window) Show() {
	// Ensure hardware acceleration is set up before showing
	w.EnableAcceleratedRendering()
	C.gtk_widget_set_visible(w.widget, C.TRUE)
}

// Present presents the window to the user (preferred in GTK4)
func (w *Window) Present() {
	// Ensure hardware acceleration is set up before presenting
	w.EnableAcceleratedRendering()
	C.gtk_window_present((*C.GtkWindow)(unsafe.Pointer(w.widget)))
}

// SetVisible sets the visibility of the window
func (w *Window) SetVisible(visible bool) {
	// Ensure hardware acceleration is set up if becoming visible
	if visible {
		w.EnableAcceleratedRendering()
	}

	var cvisible C.gboolean
	if visible {
		cvisible = C.TRUE
	} else {
		cvisible = C.FALSE
	}
	C.gtk_widget_set_visible(w.widget, cvisible)
}

// ConnectCloseRequest connects a callback function to the window's "close-request" signal
// The callback should return true to stop the default handling of the signal (prevent closing),
// or false to allow the default handling (allow closing)
func (w *Window) ConnectCloseRequest(callback func() bool) uint64 {
	return Connect(w, SignalCloseRequest, callback)
}

// DisconnectCloseRequest disconnects the close-request signal handler
func (w *Window) DisconnectCloseRequest() {
	// We'll search for callbacks connected to the SignalCloseRequest signal type
	// Ideally we would have a DisconnectBySignal function in callbacks.go to handle this more elegantly
	DisconnectAll(w)
}

// Destroy destroys the window and cleans up resources
func (w *Window) Destroy() {
	if w.widget != nil {
		// Disconnect all signals for this window
		DisconnectAll(w)
		
		// Clean up window resize detection if it was set up
		w.CleanupResizeDetection()

		// Destroy the window
		C.gtk_window_destroy((*C.GtkWindow)(unsafe.Pointer(w.widget)))
		w.widget = nil
	}
}

############################################################
# File: gtk4/windowAction.go
############################################################

// File: gtk4go/gtk4/windowActions.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Add action to window
// static void add_action_to_window(GtkWindow* window, GAction* action) {
//     g_action_map_add_action(G_ACTION_MAP(window), action);
// }
//
// // Remove action from window
// static void remove_action_from_window(GtkWindow* window, const char* name) {
//     g_action_map_remove_action(G_ACTION_MAP(window), name);
// }
import "C"

import (
	"unsafe"
)

// WindowActionGroup implements the ActionGroup interface for Window
type WindowActionGroup struct {
	win *Window
}

// AddAction adds an action to the window
func (w *WindowActionGroup) AddAction(action *Action) {
	C.add_action_to_window((*C.GtkWindow)(unsafe.Pointer(w.win.widget)), action.GetNative())
}

// RemoveAction removes an action from the window
func (w *WindowActionGroup) RemoveAction(name string) {
	cName := C.CString(name)
	defer C.free(unsafe.Pointer(cName))
	C.remove_action_from_window((*C.GtkWindow)(unsafe.Pointer(w.win.widget)), cName)
}

// GetActionGroup returns the window's action group
func (w *Window) GetActionGroup() ActionGroup {
	return &WindowActionGroup{win: w}
}



############################################################
# File: gtk4/windowResize.go
############################################################

// Package gtk4 provides window resize detection for GTK4
// File: gtk4go/gtk4/windowResize.go
package gtk4

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // Property notify callbacks for window size changes
// extern void windowPropertyNotifyCallback(GObject *object, GParamSpec *pspec, gpointer user_data);
//
// // Set up window resize detection using property notifications
// static void setupWindowResizeTracking(GtkWindow *window) {
//     // Connect to default-width property changes
//     g_signal_connect(window, "notify::default-width", 
//                     G_CALLBACK(windowPropertyNotifyCallback), window);
//     
//     // Connect to default-height property changes
//     g_signal_connect(window, "notify::default-height", 
//                     G_CALLBACK(windowPropertyNotifyCallback), window);
//
//     // Connect to width-request changes
//     g_signal_connect(window, "notify::width-request", 
//                     G_CALLBACK(windowPropertyNotifyCallback), window);
//     
//     // Connect to height-request changes
//     g_signal_connect(window, "notify::height-request", 
//                     G_CALLBACK(windowPropertyNotifyCallback), window);
//
//     // Surface state changes (maximized, fullscreen, etc.)
//     GdkSurface *surface = gtk_native_get_surface(GTK_NATIVE(window));
//     if (surface) {
//         g_signal_connect(surface, "notify::state", 
//                         G_CALLBACK(windowPropertyNotifyCallback), window);
//     }
// }
//
// // Get current window size via width/height properties
// static void getWindowSize(GtkWindow *window, int *width, int *height) {
//     // Start with default values
//     *width = 0;
//     *height = 0;
//     
//     // Try the surface - most reliable for window dimensions
//     GdkSurface *surface = gtk_native_get_surface(GTK_NATIVE(window));
//     if (surface) {
//         *width = gdk_surface_get_width(surface);
//         *height = gdk_surface_get_height(surface);
//         
//         if (*width > 0 && *height > 0) {
//             return;
//         }
//     }
//     
//     // Try with natural size
//     int natural_width, natural_height;
//     gtk_widget_measure(GTK_WIDGET(window), GTK_ORIENTATION_HORIZONTAL, -1,
//                       NULL, &natural_width, NULL, NULL);
//     gtk_widget_measure(GTK_WIDGET(window), GTK_ORIENTATION_VERTICAL, -1,
//                       NULL, &natural_height, NULL, NULL);
//                       
//     if (natural_width > 0 && natural_height > 0) {
//         *width = natural_width;
//         *height = natural_height;
//         return;
//     }
//     
//     // Get the requested size
//     int request_width, request_height;
//     gtk_widget_get_size_request(GTK_WIDGET(window), &request_width, &request_height);
//     
//     if (request_width > 0 && request_height > 0) {
//         *width = request_width;
//         *height = request_height;
//         return;
//     }
//     
//     // Last resort: use default size
//     gtk_window_get_default_size(window, width, height);
// }
import "C"

import (
	"sync"
	"sync/atomic"
	"time"
	"unsafe"
)

var (
	// Track resize state for each window
	windowResizeState      = make(map[uintptr]*windowResizeData)
	windowResizeStateMutex sync.RWMutex
)

// windowResizeData tracks resize state for a window
type windowResizeData struct {
	// Atomic fields for thread-safe access without mutex
	isResizing      atomic.Bool     // Whether window is currently being resized
	width           atomic.Int32    // Current window width
	height          atomic.Int32    // Current window height
	watcherID       atomic.Int64    // ID of the current resize watcher goroutine
	
	// Time values stored in atomic.Value
	lastResizeTime  atomic.Value    // time.Time - Last time a resize event was detected
	resizeStartTime atomic.Value    // time.Time - When resize operation began
	
	// Configuration fields (protected by mutex)
	mu                 sync.RWMutex  // Mutex for non-atomic fields
	onResizeStart      func()        // Function to call when resize starts
	onResizeEnd        func()        // Function to call when resize ends
	resizeEndThreshold time.Duration // Threshold to detect end of resize operation
}

// ResizeCallback is a function called when resize state changes
type ResizeCallback func()

//export windowPropertyNotifyCallback
func windowPropertyNotifyCallback(object *C.GObject, pspec *C.GParamSpec, userData C.gpointer) {
	windowPtr := uintptr(unsafe.Pointer(userData))

	windowResizeStateMutex.RLock()
	data, exists := windowResizeState[windowPtr]
	windowResizeStateMutex.RUnlock()

	if !exists {
		return
	}

	now := time.Now()
	data.lastResizeTime.Store(now)

	// Get current dimensions using C helper
	var width, height C.int
	C.getWindowSize((*C.GtkWindow)(unsafe.Pointer(userData)), &width, &height)
	
	// Only proceed if we got valid dimensions
	if width <= 0 || height <= 0 {
		return
	}
	
	// Load old dimensions atomically and store new dimensions atomically
	oldWidth := data.width.Load()
	oldHeight := data.height.Load()
	newWidth := int32(width)
	newHeight := int32(height)
	
	// Store the new dimensions using atomic operations
	data.width.Store(newWidth)
	data.height.Store(newHeight)

	// Check if dimensions actually changed
	if newWidth == oldWidth && newHeight == oldHeight {
		return
	}

	// Is this a new resize operation?
	wasResizing := data.isResizing.Load()
	if !wasResizing {
		// Mark as resizing using atomic operation
		data.isResizing.Store(true)
		data.resizeStartTime.Store(now)

		// Call resize start handler if set (thread-safe access)
		data.mu.RLock()
		onResizeStart := data.onResizeStart
		data.mu.RUnlock()
		
		if onResizeStart != nil {
			onResizeStart()
		}
	}

	// Ensure a watcher goroutine is running
	startResizeWatcher(data, windowPtr)
}

// startResizeWatcher ensures a single watcher goroutine is running to detect resize completion
func startResizeWatcher(data *windowResizeData, windowPtr uintptr) {
	// Generate a unique watcher ID
	newWatcherID := time.Now().UnixNano()
	
	// Try to set the new watcher ID using atomic operation, and get the old one
	oldWatcherID := data.watcherID.Swap(newWatcherID)
	
	// If oldWatcherID was 0, no watcher was running
	if oldWatcherID == 0 {
		go resizeWatcherGoroutine(data, windowPtr, newWatcherID)
	}
	// If oldWatcherID was non-zero, a watcher is already running
	// It will detect it's been replaced when it checks its ID
}

// resizeWatcherGoroutine monitors for resize completion
func resizeWatcherGoroutine(data *windowResizeData, windowPtr uintptr, myID int64) {
	// Get the threshold (thread-safe)
	data.mu.RLock()
	threshold := data.resizeEndThreshold
	data.mu.RUnlock()
	
	// Wait for a short period to see if resize continues
	time.Sleep(threshold)
	
	// Check if we're still the active watcher using atomic load
	if data.watcherID.Load() != myID {
		return // Another watcher has taken over
	}
	
	// Mark that no watcher is running using atomic operation
	data.watcherID.Store(int64(0))
	
	// Check if no new resize events have occurred
	lastResizeTime, ok := data.lastResizeTime.Load().(time.Time)
	if !ok {
		return // Type assertion failed
	}
	
	if time.Since(lastResizeTime) >= threshold {
		// Resize has ended, but only if we're still in resize state
		if data.isResizing.Swap(false) { // returns old value and sets to false atomically
			// We were resizing and now we're not
			
			// Call resize end handler if set (thread-safe)
			data.mu.RLock()
			onResizeEnd := data.onResizeEnd
			data.mu.RUnlock()
			
			if onResizeEnd != nil {
				onResizeEnd()
			}
		}
	} else {
		// Still getting resize events, start another watcher
		startResizeWatcher(data, windowPtr)
	}
}

// SetupResizeDetection sets up resize detection for a window
func (w *Window) SetupResizeDetection(onResizeStart, onResizeEnd ResizeCallback) {
	windowPtr := uintptr(unsafe.Pointer(w.widget))

	// Create resize data with thread-safe initialization
	data := &windowResizeData{
		resizeEndThreshold: 200 * time.Millisecond, // Default threshold
	}

	// Store callbacks with mutex protection
	data.mu.Lock()
	data.onResizeStart = onResizeStart
	data.onResizeEnd = onResizeEnd
	data.mu.Unlock()

	// Initialize atomic values
	data.lastResizeTime.Store(time.Time{})
	data.resizeStartTime.Store(time.Time{})
	data.watcherID.Store(int64(0))

	// Get initial window size
	var width, height C.int
	C.getWindowSize((*C.GtkWindow)(unsafe.Pointer(w.widget)), &width, &height)
	
	// Store the initial dimensions using atomic operations
	data.width.Store(int32(width))
	data.height.Store(int32(height))

	// Store in map with mutex protection
	windowResizeStateMutex.Lock()
	windowResizeState[windowPtr] = data
	windowResizeStateMutex.Unlock()

	// Set up signal connections for resize detection
	C.setupWindowResizeTracking((*C.GtkWindow)(unsafe.Pointer(w.widget)))
}

// SetupCSSOptimizedResize sets up CSS optimization during resize
func (w *Window) SetupCSSOptimizedResize() {
	// Set up resize detection with CSS optimization
	w.SetupResizeDetection(
		// On resize start
		func() {
			// Optimize all global CSS providers
			optimizeAllProviders()

			// Switch to lightweight CSS
			display := C.gdk_display_get_default()
			useResizeCSSProvider(display)
		},
		// On resize end
		func() {
			// Reset all global CSS providers
			resetAllProviders()

			// Restore normal CSS
			display := C.gdk_display_get_default()
			restoreOriginalCSSProvider(display, nil)
		},
	)
}

// IsResizing returns true if the window is currently being resized
func (w *Window) IsResizing() bool {
	windowPtr := uintptr(unsafe.Pointer(w.widget))

	windowResizeStateMutex.RLock()
	data, exists := windowResizeState[windowPtr]
	windowResizeStateMutex.RUnlock()

	if !exists {
		return false
	}

	// Use atomic operation to get the resizing state
	return data.isResizing.Load()
}

// GetSize returns the current window size
func (w *Window) GetSize() (width, height int32) {
	windowPtr := uintptr(unsafe.Pointer(w.widget))

	windowResizeStateMutex.RLock()
	data, exists := windowResizeState[windowPtr]
	windowResizeStateMutex.RUnlock()

	if !exists {
		return 0, 0
	}

	// Use atomic operations to get the dimensions
	return data.width.Load(), data.height.Load()
}

// SetResizeEndThreshold sets the time threshold for detecting the end of a resize operation
func (w *Window) SetResizeEndThreshold(threshold time.Duration) {
	windowPtr := uintptr(unsafe.Pointer(w.widget))

	windowResizeStateMutex.RLock()
	data, exists := windowResizeState[windowPtr]
	windowResizeStateMutex.RUnlock()

	if !exists {
		return
	}

	// Use mutex for non-atomic field
	data.mu.Lock()
	data.resizeEndThreshold = threshold
	data.mu.Unlock()
}

// CleanupResizeDetection cleans up resize detection for a window
func (w *Window) CleanupResizeDetection() {
	windowPtr := uintptr(unsafe.Pointer(w.widget))

	windowResizeStateMutex.Lock()
	delete(windowResizeState, windowPtr)
	windowResizeStateMutex.Unlock()
}

############################################################
# File: hello-world/main.go
############################################################

package main

import (
	"../../gtk4go"
	"../gtk4"
	"context"
	"fmt"
	"log"
	"os"
	"time"
)

func main() {
	// Initialize GTK (this is also done automatically on import)
	// 
	gtk4.EnableCallbackDebugging(true)
	if err := gtk4go.Initialize(); err != nil {
		log.Fatalf("Failed to initialize GTK: %v", err)
	}

	// Create a new application
	app := gtk4.NewApplication("com.example.HelloWorld")

	// Create a window with optimized rendering
	win := gtk4.NewWindow("Hello GTK4 from Go!")
	win.SetDefaultSize(900, 650)

	// Enable hardware-accelerated rendering
	win.EnableAcceleratedRendering()

	// Set up CSS optimization during window resize
	win.SetupCSSOptimizedResize()

	// Optimize for resizing specifically
	win.OptimizeForResizing()

	// Create a vertical box container as the main layout
	mainBox := gtk4.NewBox(gtk4.OrientationVertical, 10)

	// Create a menu bar for the application
	menuBar := gtk4.NewMenuBar()
	mainBox.Append(menuBar)

	// Create a title label
	titleLabel := gtk4.NewLabel("GTK4Go Demo Application")
	titleLabel.AddCssClass("title")
	mainBox.Append(titleLabel)

	// Create a horizontal paned container to split the UI
	paned := gtk4.NewPaned(gtk4.OrientationHorizontal,
		gtk4.WithPosition(350),
		gtk4.WithWideHandle(true),
	)

	// ---- LEFT SIDE OF PANED ----
	leftBox := gtk4.NewBox(gtk4.OrientationVertical, 10)

	// Add a menu button with popup menu
	menuButton := gtk4.NewMenuButton()
	menuButton.SetLabel("Quick Actions")
	leftBox.Append(menuButton)

	// Input section
	inputLabel := gtk4.NewLabel("Enter your name:")
	entry := gtk4.NewEntry()
	entry.SetPlaceholderText("Type your name here")
	resultLbl := gtk4.NewLabel("Hello, World!")

	// Now use a Grid for button layout
	buttonsGrid := gtk4.NewGrid(
		gtk4.WithRowSpacing(10),
		gtk4.WithColumnSpacing(10),
		gtk4.WithColumnHomogeneous(true),
	)

	// Create buttons
	helloBtn := gtk4.NewButton("Say Hello")
	aboutBtn := gtk4.NewButton("About")
	fileBtn := gtk4.NewButton("Open File")
	longTaskBtn := gtk4.NewButton("Run Long Task")

	// Add buttons to grid (col, row, width, height)
	buttonsGrid.Attach(helloBtn, 0, 0, 1, 1)
	buttonsGrid.Attach(aboutBtn, 1, 0, 1, 1)
	buttonsGrid.Attach(fileBtn, 0, 1, 1, 1)
	buttonsGrid.Attach(longTaskBtn, 1, 1, 1, 1)

	// Progress label
	progressLbl := gtk4.NewLabel("Ready")
	progressLbl.AddCssClass("progress-label")

	// Add widgets to left box
	leftBox.Append(inputLabel)
	leftBox.Append(entry)
	leftBox.Append(buttonsGrid)
	leftBox.Append(resultLbl)
	leftBox.Append(progressLbl)

	// ---- RIGHT SIDE OF PANED ----

	// Create a Stack for different content pages
	rightStack := gtk4.NewStack(
		gtk4.WithTransitionType(gtk4.StackTransitionTypeSlideLeftRight),
		gtk4.WithTransitionDuration(200),
	)

	// Stack Page 1: Info Page
	infoBox := gtk4.NewBox(gtk4.OrientationVertical, 10)
	infoBox.Append(gtk4.NewLabel("GTK4Go Information"))
	infoBox.Append(gtk4.NewLabel("This demo showcases the new layout containers:"))

	// Use a grid to display information about widgets
	infoGrid := gtk4.NewGrid(
		gtk4.WithRowSpacing(5),
		gtk4.WithColumnSpacing(10),
		gtk4.WithRowHomogeneous(false),
	)

	// Add headers
	infoGrid.Attach(gtk4.NewLabel("Widget"), 0, 0, 1, 1)
	infoGrid.Attach(gtk4.NewLabel("Description"), 1, 0, 1, 1)

	// Add widget information rows
	widgets := []string{"Grid", "Paned", "Stack", "StackSwitcher", "ScrolledWindow", "ListView"}
	descriptions := []string{
		"Arranges widgets in rows and columns",
		"Divides space between two widgets with adjustable separator",
		"Shows one widget at a time with transitions",
		"Provides buttons to switch between stack pages",
		"Provides scrolling for large content",
		"Displays items from a list model with customizable presentation",
	}

	for i, widget := range widgets {
		widgetLabel := gtk4.NewLabel(widget)
		widgetLabel.AddCssClass("info-widget")
		descLabel := gtk4.NewLabel(descriptions[i])
		descLabel.AddCssClass("info-desc")

		infoGrid.Attach(widgetLabel, 0, i+1, 1, 1)
		infoGrid.Attach(descLabel, 1, i+1, 1, 1)
	}

	infoBox.Append(infoGrid)
	rightStack.AddTitled(infoBox, "info", "Information")

	// Stack Page 2: Log Page with ScrolledWindow
	scrollWin := gtk4.NewScrolledWindow(
		gtk4.WithHScrollbarPolicy(gtk4.ScrollbarPolicyAutomatic),
		gtk4.WithVScrollbarPolicy(gtk4.ScrollbarPolicyAlways),
		gtk4.WithPropagateNaturalHeight(false), // Don't propagate natural height to allow scrolling
	)

	// Create a vertical box for log entries
	logBox := gtk4.NewBox(gtk4.OrientationVertical, 5)

	// Add some sample log entries
	for i := 1; i <= 10; i++ {
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%d] Log entry #%d", i, i))
		logEntry.AddCssClass("log-entry")
		logBox.Append(logEntry)
	}

	scrollWin.SetChild(logBox)
	rightStack.AddTitled(scrollWin, "logs", "Logs")

	// Stack Page 3: Help Page
	helpBox := gtk4.NewBox(gtk4.OrientationVertical, 10)
	helpBox.Append(gtk4.NewLabel("Help Information"))

	helpText := gtk4.NewLabel(`
Using this application:

1. Enter your name in the text field
2. Click "Say Hello" to see a greeting
3. Click "About" to learn about the app
4. Click "Open File" to select a file
5. Click "Run Long Task" to see a background task
6. Go to ListView tab to see the new ListView widget in action

This demo showcases GTK4Go's layout containers and widgets.
	`)

	helpBox.Append(helpText)
	rightStack.AddTitled(helpBox, "help", "Help")

	// Stack Page 4: ListView Example (NEW)
	listViewBox := gtk4.NewBox(gtk4.OrientationVertical, 10)
	listViewTitle := gtk4.NewLabel("ListView Example")
	listViewTitle.AddCssClass("subtitle")
	listViewBox.Append(listViewTitle)

	// Add description
	listViewDesc := gtk4.NewLabel("This demonstrates the new ListView widget with data binding and selection")
	listViewBox.Append(listViewDesc)

	// Create controls for ListView
	listViewControls := gtk4.NewBox(gtk4.OrientationHorizontal, 6)
	listViewControls.AddCssClass("controls-box")

	// Add button
	addItemBtn := gtk4.NewButton("Add Item")
	listViewControls.Append(addItemBtn)

	// Remove button
	removeItemBtn := gtk4.NewButton("Remove Selected")
	listViewControls.Append(removeItemBtn)

	// Clear button
	clearItemsBtn := gtk4.NewButton("Clear All")
	listViewControls.Append(clearItemsBtn)

	listViewBox.Append(listViewControls)

	// Create a string list model with sample data
	listModel := gtk4.NewStringList()
	for i := 1; i <= 15; i++ {
		listModel.Append(fmt.Sprintf("List Item %d", i))
	}

	// Create a selection model (SingleSelection)
	selectionModel := gtk4.NewSingleSelection(listModel,
		gtk4.WithAutoselect(true),
		gtk4.WithInitialSelection(0),
	)

	// Create a list item factory
	factory := gtk4.NewSignalListItemFactory()

	// Setup list items with setup callback
	factory.ConnectSetup(func(listItem *gtk4.ListItem) {
		// Create a box for layout
		box := gtk4.NewBox(gtk4.OrientationHorizontal, 10)
		box.SetHExpand(true)
		box.AddCssClass("list-item-box")

		// Create an icon for visual interest
		icon := gtk4.NewLabel("•")
		icon.AddCssClass("list-item-icon")
		box.Append(icon)

		// Create a label for the item text with initial text
		// We'll use CSS to control the appearance based on position
		label := gtk4.NewLabel("List Item")
		label.AddCssClass("list-item-label")
		box.Append(label)

		// Set the box as the child of the list item
		listItem.SetChild(box)
	})

	// Bind data to list items with bind callback
	factory.ConnectBind(func(listItem *gtk4.ListItem) {
		// Get the box from the list item
		boxWidget := listItem.GetChild()

		// Get the position for reference
		position := listItem.GetPosition()

		// In a real implementation, we'd find the label inside the box and update its text
		// For the demo, we'll modify both style classes to reflect selection state

		// Add selected class if the item is selected
		if listItem.GetSelected() {
			boxWidget.AddCssClass("selected")
		} else {
			boxWidget.RemoveCssClass("selected")
		}

		// Since we can't easily update children, we'll set a CSS class with the position
		// and use that in the CSS to show different styles for different items
		boxWidget.AddCssClass(fmt.Sprintf("item-%d", position))
	})

	// Create list view with the selection model and factory
	listView := gtk4.NewListView(selectionModel, factory,
		gtk4.WithShowSeparators(true),
		gtk4.WithSingleClickActivate(true),
	)

	// Connect the list view activate signal
	listView.ConnectActivate(func(position int) {
		// Log the activation
		activateLog := fmt.Sprintf("[%s] ListView: Item activated at position %d",
			time.Now().Format("15:04:05"), position)

		// Create a log entry
		logEntry := gtk4.NewLabel(activateLog)
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)

		// Show a dialog with the selected item
		messageDialog := gtk4.NewMessageDialog(
			win,
			gtk4.DialogModal,
			gtk4.MessageInfo,
			gtk4.ResponseOk,
			fmt.Sprintf("You selected item at position %d", position),
		)
		messageDialog.SetTitle("ListView Item Selected")

		// Connect response handler
		messageDialog.ConnectResponse(func(responseId gtk4.ResponseType) {
			messageDialog.Destroy()
		})

		// Show the dialog
		messageDialog.Show()
	})

	// Create a scrolled window to contain the list view
	listViewScroll := gtk4.NewScrolledWindow(
		gtk4.WithHScrollbarPolicy(gtk4.ScrollbarPolicyNever),
		gtk4.WithVScrollbarPolicy(gtk4.ScrollbarPolicyAutomatic),
	)
	listViewScroll.SetChild(listView)
	listViewScroll.AddCssClass("list-view-container")

	// Add the list view scrolled window to the box
	listViewBox.Append(listViewScroll)

	// Connect the add item button
	addItemBtn.ConnectClicked(func() {
		// Add a new item to the list model
		newItem := fmt.Sprintf("New List Item %d", listModel.GetNItems()+1)
		listModel.Append(newItem)

		// Log the action
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Added new list item: %s",
			time.Now().Format("15:04:05"), newItem))
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)
	})

	// Connect the remove item button
	removeItemBtn.ConnectClicked(func() {
		// Get the selected position
		selectedPos := selectionModel.GetSelected()

		// Check if there's a valid selection
		if selectedPos >= 0 && selectedPos < listModel.GetNItems() {
			// Get the item text before removing it
			itemText := fmt.Sprintf("Item %d", selectedPos+1)

			// Remove the item
			listModel.Remove(selectedPos)

			// Log the action
			logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Removed list item: %s",
				time.Now().Format("15:04:05"), itemText))
			logEntry.AddCssClass("log-entry")
			logBox.Prepend(logEntry)
		}
	})

	// Connect the clear items button
	clearItemsBtn.ConnectClicked(func() {
		// Clear all items by removing them one by one from the end
		for i := listModel.GetNItems() - 1; i >= 0; i-- {
			listModel.Remove(i)
		}

		// Log the action
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Cleared all list items",
			time.Now().Format("15:04:05")))
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)

		// Add a default item back
		listModel.Append("List Empty")
	})

	// Add the ListView page to the stack
	rightStack.AddTitled(listViewBox, "listview", "ListView")

	// Create a stack switcher for the right stack
	stackSwitcher := gtk4.NewStackSwitcher(rightStack)

	// Create a box to hold the stack switcher and stack
	rightBox := gtk4.NewBox(gtk4.OrientationVertical, 5)
	rightBox.Append(stackSwitcher)
	rightBox.Append(rightStack)

	// Add left and right sides to the paned container
	paned.SetStartChild(leftBox)
	paned.SetEndChild(rightBox)

	// Add paned container to main box
	mainBox.Append(paned)

	// Add CSS classes to the buttons
	helloBtn.AddCssClass("square-button")
	aboutBtn.AddCssClass("square-button")
	fileBtn.AddCssClass("square-button")
	longTaskBtn.AddCssClass("square-button")

	// Load CSS for styling - using caching for better performance
	cssProvider, err := gtk4.LoadCSS(`
		.title {
			font-size: 18px;
			font-weight: bold;
			padding: 10px;
			color: #2a76c6;
		}
		.subtitle {
			font-size: 16px;
			font-weight: bold;
			padding: 8px;
			color: #2a76c6;
		}
		.square-button {
			border-radius: 4px;
			padding: 8px 16px;
			background-color: #3584e4;
			color: white;
			font-weight: bold;
		}
		.square-button:hover {
			background-color: #1c71d8;
		}
		.square-button.disabled {
			opacity: 0.6;
		}
		window {
			background-color: #f6f5f4;
		}
		entry {
			padding: 8px;
			margin: 4px 0;
		}
		label {
			margin: 4px 0;
		}
		.dialog-content-area {
			padding: 16px;
		}
		.dialog-button-area {
			padding: 8px;
			background-color: #f0f0f0;
		}
		.dialog-message {
			font-size: 14px;
			padding: 8px;
		}
		.info-dialog .dialog-message {
			color: #0066cc;
		}
		.warning-dialog .dialog-message {
			color: #ff6600;
		}
		.error-dialog .dialog-message {
			color: #cc0000;
		}
		.question-dialog .dialog-message {
			color: #006633;
		}
		.progress-label {
			font-style: italic;
			color: #666666;
		}
		.info-widget {
			font-weight: bold;
			color: #2a76c6;
		}
		.info-desc {
			color: #333333;
		}
		.log-entry {
			font-family: monospace;
			padding: 2px 5px;
			text-align: left;
			border-bottom: 1px solid #e0e0e0;
		}
		.log-entry:nth-child(odd) {
			background-color: #f5f5f5;
		}
		.list-view-container {
			border: 1px solid #cccccc;
			border-radius: 4px;
			min-height: 250px;
		}
		.list-item-box {
			padding: 8px;
			border-radius: 3px;
			transition: background-color 0.2s ease;
		}
		.list-item-box.selected {
			background-color: #3584e4;
			color: white;
		}
		.list-item-icon {
			font-size: 16px;
			color: #3584e4;
			font-weight: bold;
		}
		.list-item-box.selected .list-item-icon {
			color: white;
		}
		.list-item-label {
			font-size: 14px;
		}
		/* Add position-based styling using the item-X classes */
		.list-item-box.item-0 .list-item-label:after { content: " 1"; }
		.list-item-box.item-1 .list-item-label:after { content: " 2"; }
		.list-item-box.item-2 .list-item-label:after { content: " 3"; }
		.list-item-box.item-3 .list-item-label:after { content: " 4"; }
		.list-item-box.item-4 .list-item-label:after { content: " 5"; }
		.list-item-box.item-5 .list-item-label:after { content: " 6"; }
		.list-item-box.item-6 .list-item-label:after { content: " 7"; }
		.list-item-box.item-7 .list-item-label:after { content: " 8"; }
		.list-item-box.item-8 .list-item-label:after { content: " 9"; }
		.list-item-box.item-9 .list-item-label:after { content: " 10"; }
		.list-item-box.item-10 .list-item-label:after { content: " 11"; }
		.list-item-box.item-11 .list-item-label:after { content: " 12"; }
		.list-item-box.item-12 .list-item-label:after { content: " 13"; }
		.list-item-box.item-13 .list-item-label:after { content: " 14"; }
		.list-item-box.item-14 .list-item-label:after { content: " 15"; }
		.list-item-box.item-15 .list-item-label:after { content: " 16"; }
		.list-item-box.item-16 .list-item-label:after { content: " 17"; }
		.list-item-box.item-17 .list-item-label:after { content: " 18"; }
		.list-item-box.item-18 .list-item-label:after { content: " 19"; }
		.list-item-box.item-19 .list-item-label:after { content: " 20"; }
		/* Add more for additional items as needed */
		.controls-box {
			padding: 8px;
			margin-bottom: 8px;
			background-color: #f0f0f0;
			border-radius: 4px;
		}
	`)
	if err != nil {
		log.Printf("Failed to load CSS: %v", err)
	} else {
		// Apply CSS provider to the entire application
		gtk4.AddProviderForDisplay(cssProvider, 600)
	}

	// Define functions for common operations to be shared between buttons and menu items
	sayHello := func() {
		name := entry.GetText()
		if name == "" {
			name = "World"
		}

		// Create a simple info dialog
		dialog := gtk4.NewMessageDialog(
			win,
			gtk4.DialogModal,
			gtk4.MessageInfo,
			gtk4.ResponseOk,
			fmt.Sprintf("Hello, %s! Nice to meet you.", name),
		)
		dialog.SetTitle("Greeting")

		// Connect response handler before showing the dialog
		dialog.ConnectResponse(func(responseId gtk4.ResponseType) {
			fmt.Printf("Dialog response: %d\n", responseId)
			dialog.Destroy() // Destroy the dialog when done

			// Add log entry for the action
			logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Greeted %s", time.Now().Format("15:04:05"), name))
			logEntry.AddCssClass("log-entry")
			logBox.Prepend(logEntry)
		})

		// Show the dialog
		dialog.Show()

		resultLbl.SetText(fmt.Sprintf("Hello, %s!", name))
	}

	showAboutDialog := func() {
		// Create a custom about dialog
		dialog := gtk4.NewDialog("About This Application", win, gtk4.DialogModal|gtk4.DialogDestroyWithParent)

		// Get the content area of the dialog
		content := dialog.GetContentArea()

		// Add some content to the dialog
		titleLabel := gtk4.NewLabel("GTK4Go Demo Application")
		titleLabel.AddCssClass("title")
		descLabel := gtk4.NewLabel("This is a simple demonstration of GTK4 bindings for Go.")
		versionLabel := gtk4.NewLabel("Version: 1.0.0")
		featuresLabel := gtk4.NewLabel("New Features: ListView with data binding and selection")

		// Add widgets to the content area
		content.Append(titleLabel)
		content.Append(descLabel)
		content.Append(versionLabel)
		content.Append(featuresLabel)

		// Add padding to the content area
		content.SetSpacing(10)

		// Add OK button to the dialog
		dialog.AddButton("OK", gtk4.ResponseOk)

		// Connect response handler
		dialog.ConnectResponse(func(responseId gtk4.ResponseType) {
			fmt.Printf("About dialog response: %d\n", responseId)
			dialog.Destroy()

			// Add log entry for the action
			logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Opened About dialog", time.Now().Format("15:04:05")))
			logEntry.AddCssClass("log-entry")
			logBox.Prepend(logEntry)

			// Switch to logs tab
			rightStack.SetVisibleChildName("logs")
		})

		// Show the dialog
		dialog.Show()
	}

	showOpenFileDialog := func() {
		// Show a confirmation dialog
		confirmDialog := gtk4.NewMessageDialog(
			win,
			gtk4.DialogModal,
			gtk4.MessageQuestion,
			gtk4.ResponseYes|gtk4.ResponseNo,
			"Do you want to open a file?",
		)
		confirmDialog.SetTitle("Confirm Action")

		// Connect response handler for the confirmation dialog
		confirmDialog.ConnectResponse(func(responseId gtk4.ResponseType) {
			fmt.Printf("Confirm dialog response: %d\n", responseId)
			confirmed := (responseId == gtk4.ResponseYes)
			confirmDialog.Destroy()

			if confirmed {
				// Create file open dialog
				fileDialog := gtk4.NewFileDialog("Select a File", win, gtk4.FileDialogActionOpen)

				// Connect response handler for the file dialog
				fileDialog.ConnectResponse(func(responseId gtk4.ResponseType) {
					fmt.Printf("File dialog response: %d\n", responseId)
					if responseId == gtk4.ResponseAccept {
						filename := fileDialog.GetFilename()
						if filename != "" {
							// Update UI
							resultLbl.SetText(fmt.Sprintf("Selected file: %s", filename))

							// Log the selection
							fmt.Printf("Selected file: %s\n", filename)

							// Add log entry for the action
							logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Selected file: %s",
								time.Now().Format("15:04:05"), filename))
							logEntry.AddCssClass("log-entry")
							logBox.Prepend(logEntry)

							// Switch to logs tab
							rightStack.SetVisibleChildName("logs")
						}
					}
					fileDialog.Destroy()
				})

				// Show the file dialog
				fileDialog.Show()
			}
		})

		// Show the confirmation dialog
		confirmDialog.Show()
	}

	clearInput := func() {
		// Clear the entry field
		entry.SetText("")
		resultLbl.SetText("Hello, World!")

		// Add log entry for the action
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Cleared input", time.Now().Format("15:04:05")))
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)
	}

	showInfoTab := func() {
		rightStack.SetVisibleChildName("info")
	}

	showLogsTab := func() {
		rightStack.SetVisibleChildName("logs")
	}

	showHelpTab := func() {
		rightStack.SetVisibleChildName("help")
	}

	showListViewTab := func() {
		rightStack.SetVisibleChildName("listview")
	}

	runLongTask := func() {
		// Only implement if a task is not already running
		if cancelFunc != nil {
			// Cancel the current task
			cancelFunc()
			cancelFunc = nil
			longTaskBtn.SetLabel("Run Long Task")
			progressLbl.SetText("Task cancelled")
			return
		}

		// Update UI to show task is starting
		longTaskBtn.SetLabel("Cancel Task")
		longTaskBtn.AddCssClass("disabled")
		progressLbl.SetText("Starting task...")
		progressLbl.AddCssClass("progress-label")

		// Add log entry for starting the task
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Started long task", time.Now().Format("15:04:05")))
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)

		// Switch to logs tab
		rightStack.SetVisibleChildName("logs")

		// Start a background task
		cancelFunc = gtk4go.QueueBackgroundTask(
			"long-task",
			func(ctx context.Context, progress func(percent int, message string)) (interface{}, error) {
				// Simulate a long task with 10 steps
				for i := 0; i <= 100; i += 10 {
					// Check for cancellation
					select {
					case <-ctx.Done():
						return nil, ctx.Err()
					default:
						// Continue processing
					}

					// Update progress
					progress(i, fmt.Sprintf("Processing step %d of 10", i/10))

					// Add log entry for each step
					progressMsg := fmt.Sprintf("Task step %d of 10 completed", i/10)
					gtk4go.RunOnUIThread(func() {
						logStep := gtk4.NewLabel(fmt.Sprintf("[%s] %s",
							time.Now().Format("15:04:05"), progressMsg))
						logStep.AddCssClass("log-entry")
						logBox.Prepend(logStep)
					})

					// Simulate work
					time.Sleep(500 * time.Millisecond)
				}

				// Return some result data
				return "Task completed successfully!", nil
			},
			func(result interface{}, err error) {
				// Reset button
				longTaskBtn.SetLabel("Run Long Task")
				longTaskBtn.RemoveCssClass("disabled")

				// Update result based on success or failure
				if err != nil {
					if err == context.Canceled {
						progressLbl.SetText("Task was cancelled")

						// Add log entry for cancellation
						logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Task cancelled",
							time.Now().Format("15:04:05")))
						logEntry.AddCssClass("log-entry")
						logBox.Prepend(logEntry)
					} else {
						progressLbl.SetText(fmt.Sprintf("Error: %v", err))

						// Add log entry for error
						logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Task error: %v",
							time.Now().Format("15:04:05"), err))
						logEntry.AddCssClass("log-entry")
						logBox.Prepend(logEntry)
					}
				} else {
					progressLbl.SetText(result.(string))

					// Add log entry for completion
					logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] %s",
						time.Now().Format("15:04:05"), result.(string)))
					logEntry.AddCssClass("log-entry")
					logBox.Prepend(logEntry)
				}

				// Clear the cancel function
				cancelFunc = nil
			},
			func(percent int, message string) {
				// This runs on the UI thread to show progress
				progressLbl.SetText(fmt.Sprintf("%d%% - %s", percent, message))
			},
		)
	}

	exitApp := func() {
		// Exit the application
		os.Exit(0)
	}

	// Connect button click and enter events to the functions
	helloBtn.ConnectClicked(sayHello)
	entry.ConnectActivate(sayHello)
	aboutBtn.ConnectClicked(showAboutDialog)
	fileBtn.ConnectClicked(showOpenFileDialog)
	longTaskBtn.ConnectClicked(runLongTask)

	// Get the application's action group
	actionGroup := app.GetActionGroup()

	// Create actions for the menu items
	sayHelloAction := gtk4.NewAction("say_hello", sayHello)
	actionGroup.AddAction(sayHelloAction)

	openAction := gtk4.NewAction("open", showOpenFileDialog)
	actionGroup.AddAction(openAction)

	saveAction := gtk4.NewAction("save", func() {
		// Implement save functionality (placeholder)
		fmt.Println("Save action triggered")
		resultLbl.SetText("Save action triggered (not implemented)")

		// Add log entry for the action
		logEntry := gtk4.NewLabel(fmt.Sprintf("[%s] Save action triggered (not implemented)",
			time.Now().Format("15:04:05")))
		logEntry.AddCssClass("log-entry")
		logBox.Prepend(logEntry)
	})
	actionGroup.AddAction(saveAction)

	clearAction := gtk4.NewAction("clear", clearInput)
	actionGroup.AddAction(clearAction)

	aboutAction := gtk4.NewAction("about", showAboutDialog)
	actionGroup.AddAction(aboutAction)

	logsAction := gtk4.NewAction("logs", showLogsTab)
	actionGroup.AddAction(logsAction)

	infoAction := gtk4.NewAction("info", showInfoTab)
	actionGroup.AddAction(infoAction)

	helpAction := gtk4.NewAction("help", showHelpTab)
	actionGroup.AddAction(helpAction)

	listViewAction := gtk4.NewAction("listview", showListViewTab)
	actionGroup.AddAction(listViewAction)

	taskAction := gtk4.NewAction("task", runLongTask)
	actionGroup.AddAction(taskAction)

	exitAction := gtk4.NewAction("exit", exitApp)
	actionGroup.AddAction(exitAction)

	// Create application menu
	menu := gtk4.NewMenu()

	// Create File menu
	fileMenu := gtk4.NewMenu()
	fileOpenItem := gtk4.NewMenuItem("Open", "app.open")
	fileSaveItem := gtk4.NewMenuItem("Save", "app.save")
	fileExitItem := gtk4.NewMenuItem("Exit", "app.exit")
	fileMenu.AppendItem(fileOpenItem)
	fileMenu.AppendItem(fileSaveItem)
	fileMenu.AppendItem(fileExitItem)
	menu.AppendSubmenu("File", fileMenu)

	// Create Edit menu
	editMenu := gtk4.NewMenu()
	editClearItem := gtk4.NewMenuItem("Clear", "app.clear")
	editMenu.AppendItem(editClearItem)
	menu.AppendSubmenu("Edit", editMenu)

	// Create View menu
	viewMenu := gtk4.NewMenu()
	viewLogsItem := gtk4.NewMenuItem("Show Logs", "app.logs")
	viewInfoItem := gtk4.NewMenuItem("Show Info", "app.info")
	viewHelpItem := gtk4.NewMenuItem("Show Help", "app.help")
	viewListViewItem := gtk4.NewMenuItem("Show ListView", "app.listview")
	viewMenu.AppendItem(viewLogsItem)
	viewMenu.AppendItem(viewInfoItem)
	viewMenu.AppendItem(viewHelpItem)
	viewMenu.AppendItem(viewListViewItem)
	menu.AppendSubmenu("View", viewMenu)

	// Create Tools menu
	toolsMenu := gtk4.NewMenu()
	toolsTaskItem := gtk4.NewMenuItem("Run Task", "app.task")
	toolsMenu.AppendItem(toolsTaskItem)
	menu.AppendSubmenu("Tools", toolsMenu)

	// Create Help menu
	helpMenu := gtk4.NewMenu()
	helpAboutItem := gtk4.NewMenuItem("About", "app.about")
	helpMenu.AppendItem(helpAboutItem)
	menu.AppendSubmenu("Help", helpMenu)

	// Set the menubar's menu model
	menuBar.SetMenuModel(menu)

	// Create a menu model for the menu button
	quickMenu := gtk4.NewMenu()
	quickHelloItem := gtk4.NewMenuItem("Say Hello", "app.say_hello")
	quickOpenItem := gtk4.NewMenuItem("Open File", "app.open")
	quickListViewItem := gtk4.NewMenuItem("Show ListView", "app.listview")
	quickAboutItem := gtk4.NewMenuItem("About", "app.about")
	quickExitItem := gtk4.NewMenuItem("Exit", "app.exit")

	quickMenu.AppendItem(quickHelloItem)
	quickMenu.AppendItem(quickOpenItem)
	quickMenu.AppendItem(quickListViewItem)
	quickMenu.AppendItem(quickAboutItem)
	quickMenu.AppendItem(quickExitItem)

	// Create a popover menu for the menu button and connect it
	popoverMenu := gtk4.NewPopoverMenu(quickMenu)
	menuButton.SetPopover(popoverMenu)

	// Add the main box to the window
	win.SetChild(mainBox)

	// Add the window to the application
	app.AddWindow(win)

	// Show instructions on how to test the window performance
	log.Println("Running Hello World with menus and optimized window performance.")
	log.Println("Try using the menu bar and menu button to access application features.")
	log.Println("Check out the new ListView tab to see ListView widget in action.")

	// Run the application
	os.Exit(app.Run())

	// Clean up background workers at exit
	gtk4go.DefaultWorker.Stop()
}

// Variable for long task cancellation
var cancelFunc context.CancelFunc


############################################################
# File: main.go
############################################################

// Package gtk4go provides Go bindings to GTK4.
// File: gtk4go/main.go
package gtk4go

// #cgo pkg-config: gtk4
// #include <gtk/gtk.h>
// #include <stdlib.h>
//
// // C callback for idle functions
// extern gboolean idleCallback(gpointer user_data);
//
// // Add an idle function to be called on the main loop
// static guint addIdleFunction(gpointer user_data) {
//     // Use GSourceFunc signature (gboolean (*)(gpointer)) explicitly
//     return g_idle_add((GSourceFunc)idleCallback, user_data);
// }
//
// // Remove a source from the main loop
// static void removeSource(guint source_id) {
//     g_source_remove(source_id);
// }
import "C"

import (
	"fmt"
	"runtime"
	"sync"
	"sync/atomic"
	"unsafe"
)

// uiThreadID tracks the ID of the UI thread
var uiThreadID int64

// dispatchQueue is a channel for functions to be executed on the UI thread
var dispatchQueue = make(chan func(), 100)

// initialized tracks whether GTK has been initialized
var (
	initialized bool
	initMutex   sync.Mutex
	idleHandles sync.Map // Maps uint64 keys to idle handles
	nextIdleKey uint64
)

// Initialize ensures GTK is initialized and starts the dispatch queue.
// This is automatically called when importing the package.
func Initialize() error {
	initMutex.Lock()
	defer initMutex.Unlock()

	if initialized {
		return nil
	}

	// Store the UI thread ID
	uiThreadID = threadID()

	// Check if GTK is already initialized
	if C.gtk_is_initialized() == C.FALSE {
		// Initialize GTK
		if C.gtk_init_check() == C.FALSE {
			return fmt.Errorf("failed to initialize GTK")
		}
	}

	// Start the dispatch queue processor
	go processDispatchQueue()

	initialized = true
	return nil
}

// IsUIThread returns true if the current goroutine is running on the UI thread
func IsUIThread() bool {
	return threadID() == atomic.LoadInt64(&uiThreadID)
}

// RunOnUIThread schedules a function to be executed on the UI thread.
// If called from the UI thread, the function is executed immediately.
func RunOnUIThread(fn func()) {
	if IsUIThread() {
		fn()
		return
	}
	dispatchQueue <- fn
}

// MustRunOnUIThread panics if not called from the UI thread
func MustRunOnUIThread() {
	if !IsUIThread() {
		panic("This function must be called from the UI thread")
	}
}

// threadID returns a unique identifier for the current OS thread
func threadID() int64 {
	var id int64
	// This func will be executed on the current OS thread
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	// Use the memory address of a local variable as a proxy for thread ID
	id = int64(uintptr(unsafe.Pointer(&id)))
	return id
}

// processDispatchQueue processes functions in the dispatch queue
func processDispatchQueue() {
	for fn := range dispatchQueue {
		invokeOnUIThread(fn)
	}
}

// invokeOnUIThread schedules a Go function to be executed on the UI thread
func invokeOnUIThread(fn func()) {
	// Get a unique key for this function
	key := atomic.AddUint64(&nextIdleKey, 1)

	// Store the function in the idle handles map
	idleHandles.Store(key, fn)

	// Schedule the function to be executed on the UI thread
	C.addIdleFunction(C.gpointer(uintptr(key)))
}

//export idleCallback
func idleCallback(userData C.gpointer) C.gboolean {
	// Get the key from the user data
	key := uint64(uintptr(userData))

	// Get the function from the idle handles map
	fnVal, ok := idleHandles.Load(key)
	if !ok {
		return C.FALSE
	}

	// Remove the function from the map
	idleHandles.Delete(key)

	// Call the function
	fn := fnVal.(func())
	fn()

	// Return FALSE to remove the idle function
	return C.FALSE
}

// Events returns the global GTK events channel.
func Events() chan any {
	return events
}

var (
	events = make(chan any, 10)
	mu     sync.Mutex
)

// SafeUIOperation executes a function safely on the UI thread
// and returns when the operation is complete
func SafeUIOperation(operation func()) {
	if IsUIThread() {
		operation()
		return
	}

	// Use a channel to synchronize
	done := make(chan struct{})

	RunOnUIThread(func() {
		operation()
		close(done)
	})

	// Wait for the operation to complete
	<-done
}

// init initializes the GTK4 library.
func init() {
	runtime.LockOSThread()
	// Initialize GTK
	Initialize()
}


